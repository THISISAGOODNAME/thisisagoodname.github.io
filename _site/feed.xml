<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>菊长的菊花田</title>
    <description>菊长就是我，我就是菊长.</description>
    <link>http://thisisagoodname.github.io//</link>
    <atom:link href="http://thisisagoodname.github.io//zfeed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 15 May 2015 09:10:14 +0800</pubDate>
    <lastBuildDate>Fri, 15 May 2015 09:10:14 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>vagrant搭建一个跨平台开发环境</title>
        <description>&lt;h1 id=&quot;vagrant&quot;&gt;用vagrant搭建一个跨平台开发环境&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://segmentfault.com/img/bVbg05&quot; alt=&quot;vagrant&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       &lt;a href=&quot;https://www.vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt; 是一款用来构建虚拟开发环境的工具，非常适合 php/python/ruby/java 这类语言开发 web 应用，“代码在我机子上运行没有问题”这种说辞将成为历史。&lt;/p&gt;

&lt;p&gt;       我们可以通过 Vagrant 封装一个 Linux 的开发环境，分发给团队成员。成员可以在自己喜欢的桌面系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，非常霸气。&lt;/p&gt;

&lt;!-- more --&gt;
&lt;p&gt;##安装步骤
——–&lt;/p&gt;

&lt;h3 id=&quot;virtualbox&quot;&gt;1. 安装 VirtualBox&lt;/h3&gt;

&lt;p&gt;       虚拟机还是得依靠 VirtualBox 来搭建，免费小巧。
下载地址：&lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot;&gt;https://www.virtualbox.org/wiki/Downloads&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;虽然 Vagrant 也支持 VMware，不过 VMware 是收费的，对应的 Vagrant 版本也是收费的&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vagrant-1&quot;&gt;2. 安装 Vagrant&lt;/h3&gt;

&lt;p&gt;下载地址：&lt;a href=&quot;http://downloads.vagrantup.com/&quot;&gt;http://downloads.vagrantup.com/&lt;/a&gt; 根据提示一步步安装。&lt;/p&gt;

&lt;h3 id=&quot;vagrant-2&quot;&gt;3. 添加镜像到 Vagrant&lt;/h3&gt;

&lt;p&gt;在线镜像：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
$ vagrant box add myVagrant {url}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       在&lt;a href=&quot;http://www.vagrantbox.es/&quot;&gt;http://www.vagrantbox.es/&lt;/a&gt;可以找到你想要的url，&lt;/p&gt;

&lt;p&gt;离线镜像：&lt;/p&gt;

&lt;p&gt;       假设我们下载的镜像存放路径是 &lt;code&gt;~/vagrant/box/precise64.box&lt;/code&gt;，在终端里输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
$ vagrant box add myVagrant ~/vagrant/box/precise64.box
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       &lt;code&gt;myVagrant&lt;/code&gt;是我们给这个 box 命的名字，&lt;code&gt;~/vagrant/box/precise64.box&lt;/code&gt; 是 box 所在路径&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;鉴于国内网络环境，本人建议用离线镜像&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下载官方封装好的基础镜像：&lt;/p&gt;

&lt;p&gt;Ubuntu precise 32 VirtualBox &lt;a href=&quot;http://files.vagrantup.com/precise32.box&quot;&gt;http://files.vagrantup.com/precise32.box&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ubuntu precise 64 VirtualBox &lt;a href=&quot;http://files.vagrantup.com/precise64.box&quot;&gt;http://files.vagrantup.com/precise64.box&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果你要其他系统的镜像，可以来这里下载：&lt;a href=&quot;http://www.vagrantbox.es/&quot;&gt;http://www.vagrantbox.es/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;4. 初始化开发环境&lt;/h3&gt;

&lt;p&gt;       创建一个开发目录（比如：&lt;code&gt;~/vagrant/dev&lt;/code&gt;），你也可以使用已有的目录，切换到开发目录里，用 &lt;code&gt;myVagrant&lt;/code&gt; 镜像初始化当前目录的环境：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
$ cd ~/dev  # 切换目录
$ vagrant init myVagrant  # 初始化
$ vagrant up  # 启动环境
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       你会看到终端显示了启动过程，启动完成后，我们就可以用 SSH 登录虚拟机了，剩下的步骤就是在虚拟机里配置你要运行的各种环境和参数了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
$ vagrant ssh  # SSH 登录
$ cd /vagrant  # 切换到开发目录，也就是宿主机上的 `~/vagrant/dev`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;~/vagrant/dev&lt;/code&gt; 目录对应虚拟机中的目录是 &lt;code&gt;/vagrant&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Windows 用户注意&lt;/strong&gt;：Windows 终端并不支持 ssh，所以需要安装第三方 SSH 客户端，比如：Putty、Cygwin 等。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5. 其他设置&lt;/h3&gt;

&lt;p&gt;       Vagrant 初始化成功后，会在初始化的目录里生成一个 &lt;code&gt;Vagrantfile&lt;/code&gt; 的配置文件，可以修改配置文件进行个性化的定制。&lt;/p&gt;

&lt;p&gt;       Vagrant 默认是使用端口映射方式将虚拟机的端口映射本地从而实现类似 &lt;code&gt;http://localhost:80&lt;/code&gt; 这种访问方式，这种方式比较麻烦，新开和修改端口的时候都得编辑。相比较而言，host-only 模式显得方便多了。打开 &lt;code&gt;Vagrantfile&lt;/code&gt;，将下面这行的注释去掉（移除 &lt;code&gt;#&lt;/code&gt;）并保存：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
config.vm.network :private_network, ip: &quot;192.168.33.10&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       &lt;code&gt;$ vagrant reload &lt;/code&gt;重启虚拟机，这样我们就能用 &lt;code&gt;192.168.33.10&lt;/code&gt; 访问这台机器了，你可以把 IP 改成其他地址，只要不产生冲突就行。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;6. 打包分发&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
$ vagrant package
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       打包完成后会在当前目录生成一个 &lt;code&gt;package.box&lt;/code&gt; 的文件，将这个文件传给其他用户，其他用户只要添加这个 box 并用其初始化自己的开发目录就能得到一个一模一样的开发环境了&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;7. 常用命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
$ vagrant init  # 初始化
$ vagrant up  # 启动虚拟机
$ vagrant halt  # 关闭虚拟机
$ vagrant reload  # 重启虚拟机
$ vagrant ssh  # SSH 至虚拟机
$ vagrant status  # 查看虚拟机运行状态
$ vagrant destroy  # 销毁当前虚拟机
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       更多内容请查阅官方文档 &lt;a href=&quot;http://docs.vagrantup.com/v2/cli/index.html&quot;&gt;http://docs.vagrantup.com/v2/cli/index.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;sever&quot;&gt;8. Sever的一些注意事项&lt;/h3&gt;

&lt;p&gt;       使用 Apache/Nginx 时会出现诸如图片修改后但页面刷新仍然是旧文件的情况，是由于静态文件缓存造成的。需要对虚拟机里的 Apache/Nginx 配置文件进行修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# Apache 配置添加:
EnableSendfile off

# Nginx 配置添加:
sendfile off;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vagrant--waiting-for-vm-to-boot-&quot;&gt;9. 使用过程中强制断电导致 Vagrant 启动失败，停留在 Waiting for VM to boot 的解决方法&lt;/h3&gt;

&lt;p&gt;       有时候 &lt;code&gt;vagrant up&lt;/code&gt; 会启动失败，一直停留在下面这个环节，同时占用 100% CPU：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[default] Booting VM...
[default] Waiting for VM to boot. This can take a few minutes.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       这个时候我们只能在 VirtualBox 管理面板强制断电关机。当再次运行 vagrant up 的时候，仍然无法进入系统，在 VirtualBox 中可以看到一个 GRUB 界面。这是 GRUB 的安全模式界面（Ubuntu 系统中常见）。这个界面默认没有倒计时，因此导致了我们无法进入系统。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;       用 &lt;code&gt;VirtualBox&lt;/code&gt; 面板运行该系统，在 GRUB 界面回车登录系统，用户名：&lt;code&gt;vagrant&lt;/code&gt;，密码：&lt;code&gt;vagrant&lt;/code&gt;，编辑 &lt;code&gt;/etc/grub.d/00_header&lt;/code&gt;，找到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
if [ &quot;\${recordfail}&quot; = 1 ]; then
  set timeout=-1
将 -1 改成 10 即可：

if [ &quot;\${recordfail}&quot; = 1 ]; then
  set timeout=10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       再运行 &lt;code&gt;$ update-grub&lt;/code&gt; 更新 GRUB，关机后再用 &lt;code&gt;$ vagrant up&lt;/code&gt; 启动就能正常启动了。&lt;/p&gt;

&lt;h3 id=&quot;vagrant-3&quot;&gt;10. 共享一下我自己做的一个vagrant镜像&lt;/h3&gt;

&lt;p&gt;       系统Ubuntu14.04 64bit，软件只安装了git和zsh(oh-my-zsh,并且启动了git和autojump插件)还有autojump。&lt;/p&gt;

&lt;p&gt;链接: &lt;a href=&quot;http://pan.baidu.com/s/1dDfHsDN&quot;&gt;http://pan.baidu.com/s/1dDfHsDN&lt;/a&gt; 密码: m4vc&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;       本篇文章所用程序版本 VirtualBox 4.3.18，Vagrant 1.7.2，本文参考了&lt;a href=&quot;http://segmentfault.com/a/1190000000264347&quot;&gt;http://segmentfault.com/a/1190000000264347&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2015/05/13/vagrantbasic.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2015/05/13/vagrantbasic.html</guid>
        
        <category>开发环境</category>
        
        
        <category>开发环境</category>
        
      </item>
    
      <item>
        <title>单终端分屏神器tmux</title>
        <description>&lt;h1 id=&quot;tmux&quot;&gt;tmux简单教程&lt;/h1&gt;

&lt;p&gt;       在远程到一台机器或者在本地终端下，经常发现，一个终端远远地不够用，经常需要同时打开几个，往往还希望这几个窗口只用一个应用程序(相信mac用户应该能理解我的话)，tmux正是为这种需求而生。
&lt;!-- more --&gt;
       下面几个是作者在日常工作中常用到的命令，事实上还有其他很多，但是一般用不到，也就不在这里介绍，如果有兴趣，可以参考官方教程。
tmux所有自带命令都默认需要先按Ctrl + b，然后再键入对应的命令&lt;/p&gt;

&lt;table&gt;
	&lt;tr&gt;
		&lt;td colspan=&quot;2&quot;&gt;Ctrl+b&lt;/td&gt;
		&lt;td&gt;激活控制台；此时以下按键生效&lt;/td&gt;
	&lt;/tr&gt;
	
	&lt;tr&gt;
		&lt;td rowspan=&quot;9&quot;&gt;系统操作&lt;/td&gt;
		&lt;td&gt;?&lt;/td&gt;
		&lt;td&gt;列出所有快捷键；按q返回&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;d&lt;/td&gt;
		&lt;td&gt;脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;D&lt;/td&gt;
		&lt;td&gt;选择要脱离的会话；在同时开启了多个会话时使用&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Ctrl+z&lt;/td&gt;
		&lt;td&gt;挂起当前会话&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;r&lt;/td&gt;
		&lt;td&gt;强制重绘未脱离的会话&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;s&lt;/td&gt;
		&lt;td&gt;选择并切换会话；在同时开启了多个会话时使用&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;:&lt;/td&gt;
		&lt;td&gt;进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;[&lt;/td&gt;
		&lt;td&gt;进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;~&lt;/td&gt;
		&lt;td&gt;列出提示信息缓存；其中包含了之前tmux返回的各种提示信息&lt;/td&gt;
	&lt;/tr&gt;
	
	&lt;tr&gt;
		&lt;td rowspan=&quot;10&quot;&gt;窗口操作&lt;/td&gt;
		&lt;td&gt;c&lt;/td&gt;
		&lt;td&gt;创建新窗口&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;font color=&quot;red&quot;&gt;&amp;amp;&lt;/font&gt;&lt;/td&gt;
		&lt;td&gt;关闭当前窗口&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;数字键&lt;/td&gt;
		&lt;td&gt;切换至指定窗口&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;p&lt;/td&gt;
		&lt;td&gt;切换至上一窗口&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;n&lt;/td&gt;
		&lt;td&gt;切换至下一窗口&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;l&lt;/td&gt;
		&lt;td&gt;在前后两个窗口间互相切换/td&amp;gt;
	
	&lt;tr&gt;
		&lt;td&gt;w&lt;/td&gt;
		&lt;td&gt;通过窗口列表切换窗口&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;,&lt;/td&gt;
		&lt;td&gt;重命名当前窗口；这样便于识别&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;.&lt;/td&gt;
		&lt;td&gt;修改当前窗口编号；相当于窗口重新排序&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;f&lt;/td&gt;
		&lt;td&gt;在所有窗口中查找指定文本&lt;/td&gt;
	&lt;/tr&gt;
	
	&lt;tr&gt;
		&lt;td rowspan=&quot;15&quot;&gt;面板操作&lt;/td&gt;
		&lt;td&gt;&lt;font color=&quot;red&quot;&gt;&quot;&lt;/font&gt;&lt;/td&gt;
		&lt;td&gt;将当前面板平分为上下两块&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;font color=&quot;red&quot;&gt;%&lt;/font&gt;&lt;/td&gt;
		&lt;td&gt;将当前面板平分为左右两块&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;font color=&quot;red&quot;&gt;x&lt;/font&gt;&lt;/td&gt;
		&lt;td&gt;关闭当前面板口&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;!&lt;/td&gt;
		&lt;td&gt;将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Ctrl+方向键&lt;/td&gt;
		&lt;td&gt;以1个单元格为单位移动边缘以调整当前面板大小&amp;lt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Alt+方向键&lt;/td&gt;
		&lt;td&gt;以5个单元格为单位移动边缘以调整当前面板大小&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Space&lt;/td&gt;
		&lt;td&gt;在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;q&lt;/td&gt;
		&lt;td&gt;显示面板编号&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;t&lt;/td&gt;
		&lt;td&gt;将当前面板变为时钟&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;o&lt;/td&gt;
		&lt;td&gt;在当前窗口中选择下一面板&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;font color=&quot;red&quot;&gt;方向键&lt;/font&gt;&lt;/td&gt;
		&lt;td&gt;移动光标以选择面板&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;{&lt;/td&gt;
		&lt;td&gt;向前置换当前面板&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;}&lt;/td&gt;
		&lt;td&gt;向后置换当前面板&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Alt+o&lt;/td&gt;
		&lt;td&gt;逆时针旋转当前窗口的面板&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Ctrl+o&lt;/td&gt;
		&lt;td&gt;顺时针旋转当前窗口的面板&lt;/td&gt;
	&lt;/tr&gt;
	


&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
</description>
        <pubDate>Tue, 12 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//linux/2015/05/12/tmux.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//linux/2015/05/12/tmux.html</guid>
        
        <category>Linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Linux解压压缩和grep总结</title>
        <description>&lt;p&gt;       参考了朋友的两篇博文，分别是&lt;a href=&quot;http://he-tao.github.io/linux/unix/linux_compression_cmd&quot;&gt;Linux 文件解压及压缩命令&lt;/a&gt;和&lt;a href=&quot;http://he-tao.github.io/linux/unix/grep/&quot;&gt;Grep&lt;/a&gt;
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h1 id=&quot;linux-&quot;&gt;Linux 文件解压及压缩命令&lt;/h1&gt;

&lt;p&gt;Linux下，通常需要用tar命令进行解压和压缩操作，针对不同的压缩文件格式，tar命令的参数也不相同。&lt;/p&gt;

&lt;h2 id=&quot;tar-&quot;&gt;tar 命令的常用参数含义:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
Main operation mode:

 -A, --catenate, --concatenate   append tar files to an archive
 -c, --create               create a new archive
 -d, --diff, --compare      find differences between archive and file system
     --delete               delete from the archive (not on mag tapes!)
 -r, --append               append files to the end of an archive
 -t, --list                 list the contents of an archive
     --test-label           test the archive volume label and exit
 -u, --update               only append files newer than copy in archive
 -x, --extract, --get       extract files from an archive
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;常见压缩文件格式解压参数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;.tar.Z 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ tar Zxvf FileName.tar.Z
[压缩]$ tar Zcvf FileName.tar.Z
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.zip 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[压缩]$ unzip FileName.zip
[解压]$ zip
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.gz 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ gunzip FileName.gz
[  或]$ gzip -d FileName.gz
[压缩]$ gzip FileName
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.tar.gz 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ tar zxvf FileName.tar.gz
[压缩]$ tar zcvf FileName.tar.gz DirNamee
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.bz2 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ bzip2 -d FileName.bz2
[  或]$ bunzip2 FileName.bz2
[压缩]$ bzip2 -z FileName
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.tar.bz2 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ tar jxvf FileName.tar.bz2
[压缩]$ tar jcvf FileName.tar.bz2 DirName
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.bz 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ bzip2 -d FileName.bz
[  或]$ bunzip2 FileName.bz
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.tar.bz 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ tar jxvf FileName.tar.bz
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.Z 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ uncompress FileName.Z
[压缩]$ compress FileName
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.tgz 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ tar zxvf FileName.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.tar.tgz 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ tar zxvf FileName.tar.tgz
[压缩]$ tar zcvf FileName.tar.tgz FileName
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.zip 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ unzip FileName.zip
[压缩]$ zip FileName.zip DirName
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.rar 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ rar e FileDir
[压缩]$ rar a FileName.rar
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.tar.lz 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ tar xvf filename.tar.lz
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.tar.xz 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ xz -d filename.tar.xz
[压缩]$ xz -Z FileDir
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.lzma格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ lzma -d filename.lzma
[压缩]$ lzma -k FileDir
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.tar 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解包]$ tar xvf FileName.tar
[打包]$ tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;.lha格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
[解压]$ lha -e FileName.lha
[压缩]$ lha -a FileName.lha FileName
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;grep&quot;&gt;Grep命令&lt;/h1&gt;

&lt;p&gt;指定要搜索的单词&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -w &quot;word&quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索以特定字符串开头的单词&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;\&amp;lt;word&#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索以特定字符串结尾的单词&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;word\&amp;gt;&#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索以特定字符串开头的行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;^word&#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索以特定字符串结尾的行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;word$&#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示上下文&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;显示 n 行上文&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;word&#39; -B n&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;显示 n 行下文&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;word&#39; -A n&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;显示上文和下文各 n 行&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;word&#39; -C n&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正则表达式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-e选项： 将模式串作为正则表达式进行匹配。&lt;/li&gt;
  &lt;li&gt;-G选项： 模式串是基本正则表达式。&lt;/li&gt;
  &lt;li&gt;-E选项： 模式串是扩展正则表达式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;过滤模式串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -v &#39;word&#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找所有不符合条件的行。&lt;/p&gt;

&lt;p&gt;POSIX字符集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;[[:space:]]&#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示出所有有空格的行。&lt;/p&gt;

&lt;p&gt;其他POSIX字符集的用法同上例。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;在一个目录下的所有文件中寻找一个字符串&lt;/h2&gt;

&lt;p&gt;举例：需要在code目录下寻找main_func符号，只需写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &#39;main_func&#39; code/ -r&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可，为了增强搜索结果的可读性，可以写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep --color -n &#39;main_func&#39; code/ -r -C 2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，–color表示彩色输出，-n表示显示行号，即可以清楚地看见匹配的位置，-C 2表示输出两行上下文，进一步增强搜索结果的可读性。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//linux/2015/05/11/new-post.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//linux/2015/05/11/new-post.html</guid>
        
        <category>Linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>[转载]如何以《红楼梦》为题材制作一款手游</title>
        <description>&lt;p&gt;       此文是知乎问题“如何以《红楼梦》为题材，制作一款网络游戏？”下面的一篇精彩回复，作者脑洞大开，套用目前手游市场最为流行的“模板”，策划出了13款“全新”的红楼梦IP手游。&lt;a href=&quot;http://www.unitymanual.com/thread-39829-1-1.html&quot;&gt;原文链接&lt;/a&gt;。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;以宝玉和后宫们恋爱为主题的GALGAME，名字可以叫《衔着宝玉出生的我生活在富贵家庭犯了中二病到底该和哪个妹妹结婚呢？》&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_015.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图片里的是黛玉，这段是宝玉看到黛玉时的内心独白~群里表示手游圈喜欢把三国武将改成女性，那我们也可以把金陵十二钗改成男性么！据说腐女的钱特别容易赚：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_014.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;男版黛玉。但这样真能吸引到少女么……我的脑回路是不是跑偏了？模仿COC的《大观园冲突》，“建造自己的大观园，掠夺好友的女眷吧！”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_013.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《大观园冲突》&lt;/p&gt;

&lt;p&gt;有些褪潮流，但还颇受传统手机玩家欢迎的《愤怒的宝玉》：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_012.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《愤怒的宝玉》&lt;/p&gt;

&lt;p&gt;女娲将补天石抛下凡间，坠入青埂峰前，宝玉经历了多少曲折呢？请玩《FlappyStone》：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_011.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《FlappyStone》&lt;/p&gt;

&lt;p&gt;塔防类的《贾府大战刘姥姥》，刘姥姥：“我要吃空你们的贾府！”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_010.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《贾府大战刘姥姥》&lt;/p&gt;

&lt;p&gt;还有以有良心的青年判官贾雨村为主角的《逆转判官》，这次别判葫芦案了哟：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_009.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《逆转判官》&lt;/p&gt;

&lt;p&gt;不断追逐金钱和美女……不对，事业和爱情的跑酷游戏《天天逼宝》：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_008.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《天天逼宝》&lt;/p&gt;

&lt;p&gt;极具文艺范儿的中国风解谜游戏《石头碑谷》，“朽骨暗夜候多时，宝玉再试云雨情。”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_007.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《石头碑谷》&lt;/p&gt;

&lt;p&gt;还有大观园拟人的《楼娘Collection》，您看这个潇湘馆怎么样？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_006.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《楼娘Collection》&lt;/p&gt;

&lt;p&gt;备受家庭主妇(及未来家庭主妇)欢迎的三消类游戏《冰糖葫芦粉碎传奇》：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_005.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《冰糖葫芦粉碎传奇》&lt;/p&gt;

&lt;p&gt;男性向可以是和贾宝玉对狙的枪战游戏《穿越金陵》，实现“六亿食指的枪战梦想”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_004.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;《穿越金陵》你们看，这种不用动脑子的脑洞，一顿饭的功夫就能画这么多。但现实往往比脑洞更残酷，一般来说真实情况常常是这样的：
下班前10分钟(游戏行业创造力最旺盛的时间，这是不容置疑的科学)，老板召集所有核心员工头脑风暴，会上表示《红楼梦》这一题材非常火爆，是一片未被挖掘的蓝海，大家好好干，等公司上市了豪宅跑车不是梦！至于游戏类型么……
当然是动作卡牌RPG！给我盯着抄，像素级别地抄！
必须要有大地图，一关一关过！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_003.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;必须要有横版战斗，这点一下按钮就是动作游戏了，听明白我的话了么！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_002.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;必须要有装备搜集，还不能穿身上，得往肚子里塞，吃满6件升一阶！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_001.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;必须要有10连抽，各种体力、VIP、额外副本机会给我卖起！充值消费要形成循环！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/23/178000492201505102307191487964648260_000.jpg?400x267_120&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;什么？你说这和《红楼梦》原著精神不契合？
别闹了，这就是个IP，咱卖个耳熟就好！&lt;/p&gt;

&lt;p&gt;菊长的PS:红楼梦的拼音hlm用拼音输入法敲一下，然后，大家就秒懂了。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%B8%B8%E6%88%8F%E5%88%9B%E6%84%8F/2015/05/10/uohongloumeng.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%B8%B8%E6%88%8F%E5%88%9B%E6%84%8F/2015/05/10/uohongloumeng.html</guid>
        
        <category>idea</category>
        
        
        <category>游戏创意</category>
        
      </item>
    
      <item>
        <title>unity3D导入场景模型，并添加碰撞器(模型不会掉下去)</title>
        <description>&lt;h2 id=&quot;unity3d&quot;&gt;unity3D导入场景模型，并添加碰撞机&lt;/h2&gt;

&lt;p&gt;       开始使用Unity3D的时候总有一个问题，导入场景文件之后，添加的人物控制器，无论是第一人称控制器还是第三人称控制器，都会从场景中掉下去，无论怎么调节模型格式都没有。其实这是因为没有为场景添加碰撞机(Colliders)&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;unity3d-1&quot;&gt;1.把场景添加到unity3D的工程中&lt;/h3&gt;

&lt;p&gt;       我这次使用非常经典的404_urban城市场景做演示了。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;2.为场景模型生成碰撞机&lt;/h3&gt;

&lt;p&gt;       在project窗口中选中模型文件(注意，不是Hierarchy)，在inspecter面板中，勾选Generate Colliders。入下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/19/1780004922015051019582504.png&quot; alt=&quot;模型生成碰撞机&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;scene&quot;&gt;3.把场景模型添加到游戏的Scene窗口中&lt;/h3&gt;

&lt;p&gt;       模型已经导入了，运行，运行，再运行，没有拖尾，没有停顿，用这样的电脑玩游戏，那才叫爽！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/20/17800049220150510201712097.gif&quot; alt=&quot;场景模型添加到游戏&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//unity3d/2015/05/10/unity3dcolliders.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//unity3d/2015/05/10/unity3dcolliders.html</guid>
        
        <category>Unity3D</category>
        
        
        <category>unity3d</category>
        
      </item>
    
      <item>
        <title>MMD4Mecanim系统研究(三)</title>
        <description>&lt;script src=&quot;/js/SyntaxHighlighter/jquery.highlighter.js?v=20091222&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;/js/SyntaxHighlighter/highlighter.js?v=20091222&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;pmxu3dpmx2fbxpmxmaya&quot;&gt;PMX模型导入U3D使用,并使用PMX2FBX,对PMX模型完成转换，再导入到maya中,形成另外的工作流&lt;/h2&gt;

&lt;p&gt;       玩过unity和MMD的应该都知道MMD4Mecanim这个东东吧，几乎可以完美把PMX/PMD模型转成fbx导入unity。但是这个fbx不带贴图的，unity是通过对于的xml读取贴图，所以导入maya是一片灰色。
       网上能够较好应付PMD/PMX模型的也只有blender和C4D了，但blender操作和主流三维软件还是有些区别，而C4D的MMD tools总是丢材质球，简直蛋疼。
       转换之后，可以获得带贴图的FBX文件，再次导出的话，模型也&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;mmd4mecanim&quot;&gt;1.导入MMD4Mecanim插件，并导入模型&lt;/h3&gt;

&lt;p&gt;       导入模型的方法我在我的&lt;a href=&quot;./mmd4mecanimmd.html&quot;&gt;另一篇文章&lt;/a&gt;中已经详细的记录过了在此不再赘描述。&lt;/p&gt;

&lt;h3 id=&quot;mayammd4mecanimimport&quot;&gt;2.使用Maya的MMD4MecanimImport插件&lt;/h3&gt;

&lt;p&gt;       MMD4MecanimImport是博客园上一位叫做&lt;a href=&quot;http://home.cnblogs.com/u/marisa/&quot;&gt;高町☆魔理沙&lt;/a&gt;的大神制作的，&lt;a href=&quot;http://www.cnblogs.com/marisa/p/4131746.html&quot;&gt;原文链接&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;mayammd4mecanimfbx&quot;&gt;3.maya导入MMD4Mecanim生成的FBX&lt;/h3&gt;

&lt;p&gt;       安装完成MMD4MecanimImport插件之后，用该插件导入MMD4Mecanim转换的FBX模型。我用的是mac版的maya2014，MMD4Mecanim版本不能太新(15年4月版本以前的，估计是新版本修改的xml文件的一些细节，以后有机会研究maya脚本的话我会修改一下脚本文件)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101241316013571876338_001.jpg&quot; alt=&quot;导入到maya&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       导入完成，用着色模式查看一下(如果机子配置较低可以考虑用局部渲染看一下效果),然后选择导入的模型，再导出成fbx。保存，看到生成的fbx文件只有几M，相比过去的模型，连模型加贴图有几十M，小了很多。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;4.之后就可以用自己熟悉的工作流了&lt;/h3&gt;

&lt;p&gt;       我将模型导入到keyshot5中渲染一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101241316013571876338_000.jpg&quot; alt=&quot;导入到keyshot5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更多高级玩法可以去看魔理沙大神的博文原文&lt;/p&gt;

&lt;p&gt;PS:MMD4MecanimImport.py源代码如下，我做了微小的修改，使之在mac系统上使用稍微方便一些。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
import pymel.util.path as pmp
import maya.cmds as cmds
import maya.mel as mel
import maya.OpenMayaUI as OpenMayaUI
import shiboken
import os
import shutil
from PySide import QtGui, QtCore
from xml.dom.minidom import parse

class FBXExplorerQtWindow(QtGui.QMainWindow):
	def __init__(self,parent=None):
		super(FBXExplorerQtWindow,self).__init__(parent)
		self.setWindowTitle(&#39;MMD4Mecanim Import v0.1&#39;)
		self.resize( 800, 800 )
		
		widget = QtGui.QWidget()
		self.setCentralWidget(widget)
		
		mainLayout = QtGui.QVBoxLayout()
		widget.setLayout(mainLayout)
		
		self.line = QtGui.QLineEdit(self)
		self.fileBrowserWidget = QtGui.QWidget(self)
		self.dirModel = QtGui.QFileSystemModel()
		self.dirModel.setRootPath(&quot;~/Documents/&quot;)
		
		nameFilters = [&quot;*.fbx&quot;]
		self.dirModel.setNameFilters(nameFilters)
		self.dirModel.setNameFilterDisables(False)
		
		self.folderView = QtGui.QTreeView(parent=self)
		self.folderView.setModel(self.dirModel)
		self.folderView.clicked[QtCore.QModelIndex].connect(self.clicked) 
		self.folderView.doubleClicked[QtCore.QModelIndex].connect(self.doubleClicked) 
		
		self.folderView.setColumnWidth(0,250)
		
		mainLayout.addWidget(self.line,1,0)
		mainLayout.addWidget(self.folderView)

	def clicked(self,index):
		index = self.folderView.currentIndex()
		dirPath = pmp(self.dirModel.filePath(index))
		self.line.setText(dirPath.normpath())

	def doubleClicked(self,index):
		index = self.folderView.currentIndex()
		path = pmp(self.dirModel.filePath(index))
		self.openFile(path)

	def openFile(self,filePath):
		types = {&quot;.fbx&quot;:&quot;FBX&quot;}
		if filePath.ext.lower() not in types.keys():
			return
		fileType = types[filePath.ext.lower()]
		if fileType == &quot;FBX&quot;:
			nPos = filePath.rfind(&#39;/&#39;)
			dirPath = filePath[0:nPos+1]
			fileName = filePath[nPos+1:filePath.rfind(&#39;.&#39;)]
			fbxFileName = filePath[nPos+1:len(filePath)]
			xmlFileName = fileName + &#39;.xml&#39;
			xmlFilePath = dirPath + xmlFileName
			newDirPath = self.copyFileForMaya(fileName, filePath, xmlFilePath, dirPath)
			
			if os.path.exists(newDirPath):
				newFbxFilePath = newDirPath + fbxFileName
				newXmlFilePath = newDirPath + xmlFileName
				self.processRename(newFbxFilePath, newXmlFilePath)
				self.importFBXFile(newFbxFilePath)
				self.importTexture(newXmlFilePath, newDirPath)
				shutil.rmtree(newDirPath,True)
			return

	def copyFileForMaya(self, fbxFileName, fbxFilePath, xmlFilePath, dirPath):
		newDirName = &#39;.temp_&#39; + fbxFileName
		newDirPath = os.path.join(dirPath, newDirName)
		if not os.path.isdir(newDirPath):
			os.makedirs(newDirPath)
		
		newDirPath += &#39;/&#39;	
		if not os.path.exists(newDirPath):
			print newDirPath + &#39; does not exist!&#39;
			return &#39;&#39;
		
		shutil.copy(fbxFilePath, newDirPath)
		shutil.copy(xmlFilePath, newDirPath)
		return newDirPath

	def modify(self, filePath, sourceStr, targetStr):
		print &#39;modify &#39; + filePath + &#39; from &#39; + sourceStr + &#39; to &#39; + targetStr
		inputFile = open(filePath)
		lines = inputFile.readlines()
		inputFile.close()

		outputFile = open(filePath, &#39;w&#39;)
		for line in lines:
			if not line:
				break
			if sourceStr in line and not targetStr in line:
				nPos = line.find(sourceStr)
				temp1 = line[0:nPos]
				temp2 = line[nPos+len(sourceStr):len(line)]
				temp = temp1 + targetStr + temp2
				outputFile.write(temp)
			else:
				outputFile.write(line)

		outputFile.close()

	def formatName(self, name):
		newName = &#39;&#39;
		if &#39;.&#39; in name:
			nPos = name.find(&#39;.&#39;)
			newName = &#39;mat_&#39; + name[0:nPos]
		else:
			newName = &#39;mat_&#39; + name
		return newName
		
	def modifyMaterialName(self, fbxFilePath):
		inputFbxFile = open(fbxFilePath)
		inputFbxLines = inputFbxFile.readlines()
		inputFbxFile.close()
		outputFbxFile = open(fbxFilePath, &#39;w&#39;)
		tag1 = &#39;Material::&#39;
		tag2 = &#39;;Material::&#39;
		for line in inputFbxLines:
			if not line:
				break
			if tag2 in line:
				nPos1 = line.find(tag2)
				temp1 = line[0:nPos1]
				temp2 = line[nPos1+len(tag2):len(line)]
				nPos2 = temp2.find(&#39;, Model::&#39;)
				temp3 = temp2[nPos2:len(temp2)]
				materialName = self.formatName(temp2[0:nPos2])
				temp = temp1 + tag2 + materialName + temp3
				outputFbxFile.write(temp)
			elif tag1 in line:
				nPos1 = line.find(tag1)
				temp1 = line[0:nPos1]
				temp2 = line[nPos1+len(tag1):len(line)]
				nPos2 = temp2.find(&#39;&quot;&#39;)
				temp3 = temp2[nPos2:len(temp2)]
				materialName = self.formatName(temp2[0:nPos2])
				temp = temp1 + tag1 + materialName + temp3
				outputFbxFile.write(temp)
			else:
				outputFbxFile.write(line)
		outputFbxFile.close()
		
	def processRename(self, fbxFilePath, xmlFilePath):
		self.modifyMaterialName(fbxFilePath)
		self.modify(xmlFilePath, &#39;&lt;materialname&gt;&#39;, &#39;&lt;materialname&gt;mat_&#39;)
		self.modify(xmlFilePath, &#39;&lt;filename&gt;&#39;, &#39;&lt;filename&gt;../&#39;)
		print &#39;Material rename completed!&#39;

	def importFBXFile(self, filePath):
		nPos = filePath.rfind(&#39;/&#39;)
		fileName = filePath[nPos+1:filePath.rfind(&#39;.&#39;)]
		importedFile = cmds.file(filePath, i=True, type=&#39;FBX&#39;, ignoreVersion=True, ra=True, rdn=True, mergeNamespacesOnClash=False, namespace=fileName)
		print importedFile + &#39; import completed!&#39;
	
	def importTexture(self, filePath, dirPath):
		dom = parse(filePath)
		
		texFileNames = dom.getElementsByTagName(&quot;fileName&quot;)
		textures = []
		for i, texFileName in enumerate(texFileNames) :
			textures.append(dirPath.encode(&#39;shift-jis&#39;) + texFileName.childNodes[0].data.encode(&#39;shift-jis&#39;))
			if cmds.objExists(&#39;file&#39; + str(i+1)) :
				continue
			else:
				fileNode = cmds.shadingNode(&#39;file&#39;, asTexture=True)
				cmds.setAttr(fileNode + &#39;.fileTextureName&#39;, textures[i], type=&quot;string&quot;)
		print textures
		
		materialNames = dom.getElementsByTagName(&quot;materialName&quot;)	
		materialID = []
		for i, materialName in enumerate(materialNames) :
			materialID.append(materialName.childNodes[0].data)
		print materialID
		
		textureIDs = dom.getElementsByTagName(&quot;textureID&quot;)
		materialTexID = []
		for i, textureID in enumerate(textureIDs) :
			materialTexID.append(textureID.childNodes[0].data)
		print materialTexID
		
		for i, iMatID in enumerate(materialID) :
			iTexID = int(materialTexID[int(i)])+1
			if(iTexID &amp;lt;= 0):
				continue
			try:
				cmds.connectAttr(&#39;file%s.outColor&#39; %iTexID, &#39;%s.color&#39; %iMatID)
				print iMatID
			except:
				continue

def show_explorer(*args):
	ptr = OpenMayaUI.MQtUtil.mainWindow()
	widget = shiboken.wrapInstance(long(ptr),QtGui.QWidget)
	explorerWin = FBXExplorerQtWindow(widget)
	explorerWin.show()

def show_help(*args):
	cmds.confirmDialog(title = &quot;Help&quot;, message = &quot;\
Steps to import:\n\
1. Convert PMD/PMX file to FBX file in unity by using MMD4Mecanim.\n\
2. Click &#39;MMD4Mecanim Import&#39; to browse the FBX file of step1, double click to import.\n\
3. In MotionBuilder, click &#39;File/open&#39; to import the FBX file of step1 with default configuration (recommend to uncheck the material).\n\
4. In MotionBuilder, select the skeleton (or all the model) you imported at step3, click &#39;File/Send to Maya/Update Current Scene&#39;.\n\
\n\
Attention:\n\
1. The file name of fbx file and texture files should not be japanese or chinese.\n\
2. You can only import one model at a time, please save your model as the standard fbx file, then create a new scene to import another one.\n\
\n\
Enjoy! &amp;gt;_&amp;lt; \n\
\n\
Author: Takamachi Marisa\n\
Contact: http://weibo.com/u/2832212042&quot;,\
	icon = &quot;information&quot;)

def customMayaMenu():
	gMainWindow = mel.eval(&#39;$temp1=$gMainWindow&#39;)
	menus = cmds.window(gMainWindow, q = True, menuArray = True)
	found = False
	
	for menu in menus:
		label = cmds.menu(menu, q = True, label = True)
		if label == &quot;MMD4Mecanim Import&quot;:
			found = True
	
	if found == False:
		customMenu = cmds.menu(parent=gMainWindow, label = &#39;MMD4Mecanim Import&#39;)
		cmds.menuItem(parent = customMenu, label = &quot;Import MMD4Mecanim FBX&quot;, c = show_explorer)
		cmds.menuItem(parent = customMenu, label = &quot;Help&quot;, c = show_help)

# Initialize the plug-in
def initializePlugin(plugin):
	customMayaMenu()

# Uninitialize the plug-in
def uninitializePlugin(plugin):
	pass

&lt;/filename&gt;&lt;/filename&gt;&lt;/materialname&gt;&lt;/materialname&gt;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 10 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//unity3d/2015/05/10/mmd4mecanimmd3.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//unity3d/2015/05/10/mmd4mecanimmd3.html</guid>
        
        <category>Unity3D</category>
        
        <category>MMD4Mecanim</category>
        
        <category>maya</category>
        
        
        <category>unity3d</category>
        
      </item>
    
      <item>
        <title>MMD4Mecanim系统研究(二)</title>
        <description>&lt;h2 id=&quot;pmxu3dmecanim&quot;&gt;PMX模型导入U3D使用,并使用Mecanim动画系统,做一个小游戏&lt;/h2&gt;

&lt;h3 id=&quot;mmd4mecanim&quot;&gt;1.导入MMD4Mecanim插件，并导入模型&lt;/h3&gt;

&lt;p&gt;       导入模型的方法我在我的&lt;a href=&quot;./mmd4mecanimmd.html&quot;&gt;另一篇文章&lt;/a&gt;中已经详细的记录过了在此不再赘描述。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;characters&quot;&gt;2.导入Characters包&lt;/h3&gt;

&lt;p&gt;       具体操作为Assets-&amp;gt;Import Package-&amp;gt;Characters(Unity3D5.0不提供standard Assets，需要手动安装；Unity3D4.0和5.0standard Assets不同，U3D4.0是character controller)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_009.jpg&quot; alt=&quot;导入characters&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       点击Import之后，project窗口下自动生成了Standard Assets文件夹，并引入了Characters，CrossPlatform和Utility三个插件，这也是U3D5包管理的一个进步，在引入包的时候可以一定程度的分析依赖。&lt;/p&gt;

&lt;h3 id=&quot;mmdrighumanoid&quot;&gt;3.(关键)把导入的MMD模型的RIG属性改为Humanoid&lt;/h3&gt;

&lt;p&gt;       Mecanim动画系统对于人形动画提供了近乎于变态的强大支持，但使用人形动画的前提，就是模型的RIG必须调整为Humanoid(人形),在模型的inspector面板可以找到。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_008.jpg&quot; alt=&quot;RIG调整为Humanoid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       有时从原有谷歌转换为Humanoid骨骼并不完全成功，需要主动点击RIG面板下的…Configure…按钮，手动指定一下关节，之后点击Done确定，如下图所示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_007.jpg&quot; alt=&quot;手动指定关节&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;4.为转换好的模型添加动画控制器&lt;/h3&gt;

&lt;p&gt;       动画状态机可以自己写，时间所限，使用官方样例中的状态机，在project中的路径是Standard Assets/Characters/ThirdPersonCharacter/Animator/ThirdPersonAnimatorController，拖到模型的inspector面板，Animator的Controller下。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_006.jpg&quot; alt=&quot;添加动画控制器&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5.为模型添加自三人称控制脚本&lt;/h3&gt;

&lt;p&gt;       先在Hierarchy面板下选中模型，然后按Component-&amp;gt;Scripts-&amp;gt;UnityStandardAssets.Characters.ThirdPerson-&amp;gt;Third Person User Control,会自动把Third Person Character和 Third Person User Control Control两个脚本附加到模型上。如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_005.jpg&quot; alt=&quot;脚本附加到模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       然后编辑模型的Capusule Collider(胶囊体碰撞机
),最理想的状态是刚好把人物包住，胶囊体的中心也和人物模型正中心在一起。按Edit Collider可以进入手动修改模式，再按一次退出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_004.jpg&quot; alt=&quot;修改碰撞机&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       之后点击运行按钮，就可以看到很随意的站姿势了，恭喜，已经修改成功，按WSAD或者上下左右就可以控制人物移动了。记得一定要修改碰撞机(Collider)，不修改碰撞机的话，会产生模型悬空在场景之上的现象。中心选取不正确,或者碰撞机的底部和地面穿插，移动的时候会经常”蹲起”,也需要仔细修改一下。如果碰撞机总和地面穿插，可以考虑把模型沿Y周提升少许。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_003.gif&quot; alt=&quot;gameDemo1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;6.为模型添加摄像机追踪&lt;/h3&gt;

&lt;p&gt;       在Utility下找到SmoothFollow脚本，拖到Main Camera上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_002.jpg&quot; alt=&quot;SmoothFollow脚本&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       再把模型拖到脚本的Target上。记得修改Distance，Height和Rotation Damping三项，我的值是3、5、1，不配置Rotation Damping的话，摄像机不会旋转，效果并不好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_001.jpg&quot; alt=&quot;模型拖到脚本的Target上&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_000.gif&quot; alt=&quot;gameDemo2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PS:最后说一下，如果之前记得打开了子弹物理引擎，那头发和衣服能看到很好的柔体运动效果，打开方法见我前一篇MMD4Mecanim的文章。&lt;/p&gt;
</description>
        <pubDate>Sat, 09 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd2.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd2.html</guid>
        
        <category>Unity3D</category>
        
        <category>MMD4Mecanim</category>
        
        
        <category>unity3d</category>
        
      </item>
    
      <item>
        <title>MMD4Mecanim系统研究(一)</title>
        <description>&lt;h2 id=&quot;pmxu3dvmd&quot;&gt;PMX导入U3D引擎,并导入VMD动画&lt;/h2&gt;

&lt;h3 id=&quot;mmd4mecanim&quot;&gt;1.导入MMD4Mecanim插件&lt;/h3&gt;

&lt;p&gt;       MMD4Mecanim是一个免费插件，&lt;a href=&quot;http://stereoarts.jp/&quot;&gt;官网&lt;/a&gt;，MMD4Mecanim的开发，截止本文写作，已经更新到MMD4Mecanim_Beta_20150508版本，本文也是以该版本进行演示。(而且截止到本文写作时，PMX2FBX已经有提取出来作为U3D独立插件的版本，我将会在日后写篇文章写依靠该插件将PMX文件和贴图都完整导入maya软件，并输出减面和贴图整合的FBX文件的文章。)MMD4Mecanim插件官方并没有指定需要的U3D版本，但使用了dll插件功能(以DLL插件的形式提供bullet物理引擎)，这个过去只有unity pro版才有，为了安全，我使用Unity3D 5.0.0f4 pro版做演示。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_009.jpg&quot; alt=&quot;导入MMD4Mecanim插件&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       进度条成功读完，no error no warning(U3D5导入15年3月更新更早版本的MMD4Mecanim也许会有问题,用4.6.3的请无视)，project目录下，有了三个文件夹，分别是BulletXNA，MMD4Mecanim，Plugins。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;2.导入模型文件&lt;/h3&gt;

&lt;p&gt;       把自己珍藏的PMX文件整个文件夹拖到project窗口，或者手动复制到项目文件夹的Assets文件夹下。我使用的是百度贴吧iRon0129大神制作的Tda Uniform Haku模型作为演示，如果侵犯了您的权利，也请通知我，我会马上修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_008.jpg&quot; alt=&quot;导入后状态&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       MMD4Mecanim会在每个PMX文件下面生成一个文件。选择这个文件，会看到作者的声明，还有新添加的MMD3Mecanim的道德提示。(绝大多数模型作者都会反对二次配布以及商业用途)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_007.jpg&quot; alt=&quot;模型声明1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       点击同意后，进入如下所示界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_006.jpg&quot; alt=&quot;模型声明2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;vmd&quot;&gt;3.添加VMD动作&lt;/h3&gt;

&lt;p&gt;       跟导入PMX文件相同，把VMD文件拖到project窗口，或者复制到Assets文件夹下，我新建了一个VMD_File文件夹，让整个工程看起来整齐。(每个VMD都是有声明的，不会提示，但需要开发者资深自重，该VMD的作者，如果我侵犯了您的权利，也请通知我)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_005.jpg&quot; alt=&quot;VMD文件导入&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       把VMD文件拖拽到VMD条目下，如果需要添加多个，则需要重复多次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_004.jpg&quot; alt=&quot;VMD文件导入2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       然后点击process即可，需要稍微等一会，这次不会有进度提示了，别误认为死机了或者U3D挂了，是在处理，添加的VMD之后会添加到FBX动画中。&lt;/p&gt;

&lt;p&gt;       成功之后，FBX文件出现，几个添加的VMD动画已经添加到FBX中，而且切段已经切好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_003.jpg&quot; alt=&quot;导入成功演示&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       将生成的FBX拖入到场景中，可以看到模型和贴图都加载的非常好，材质丢失现象也没有发生。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_002.jpg&quot; alt=&quot;拖入场景演示&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       然后把FBX中的动画拖拽到模型上，生成Animation Controller，并添加到模型上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_001.jpg&quot; alt=&quot;FBX添加动画&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       再点击运行，即可看到效果.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_000.gif&quot; alt=&quot;最终动态效果&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd.html</guid>
        
        <category>Unity3D</category>
        
        <category>MMD4Mecanim</category>
        
        
        <category>unity3d</category>
        
      </item>
    
      <item>
        <title>数字图像处理-离散余弦变换的蝶形运算</title>
        <description>&lt;p&gt;转自&lt;a href=&quot;http://blog.csdn.net/sno_guo/article/details/8039659&quot;&gt;http://blog.csdn.net/sno_guo/article/details/8039659&lt;/a&gt;,并自己做了一些内容上的删减。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;为什么要进行变换&lt;/h3&gt;

&lt;p&gt;       空间图像数据通常是很难压缩的：相邻的采样点具有很强的相关性（相互关联的），而且能量一般平均分布在一幅图像中，从而要想丢掉某些数据和降低数据精度而不明显影响图像质量，就要选择合适的变换，方法，使图像易于被压缩。适合压缩的变换方法要有这样几个性质：&lt;/p&gt;

&lt;!-- more --&gt;

&lt;ul&gt;
  &lt;li&gt;1.可以聚集图像的能量（将能量集中到少数有意义的数值上）；如下图：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.163.com/photo/QNUqLLTRxzhgqpkFYPQY3w==/1183883752046274017.jpg&quot; alt=&quot;三维DCT示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2.可以除去数据之间的相关性（以使丢掉不重要的数据对图像的质量影响很少）。&lt;/li&gt;
  &lt;li&gt;3.变换方法应该适合用软硬件实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dct&quot;&gt;DCT算法的实例&lt;/h3&gt;
&lt;p&gt;       H264视频压缩&lt;/p&gt;

&lt;h3 id=&quot;x4dct&quot;&gt;4x4整数DCT推导过程&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_k=C_k\sum_{n=0}^{N-1}x_ncos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;

&lt;p&gt;       将上面的DCT公式转变为矩阵公式，为了说明标准矩阵中整数的变换和反变换，先假设&lt;script type=&quot;math/tex&quot;&gt;$d=\frac{c}{b}&lt;/script&gt;$。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A=
\begin{bmatrix}
 a &amp; a &amp; a &amp; a\\\
 b &amp; c &amp; -c &amp;-b \\\
 a &amp; -a &amp; -a &amp; a \\\
 c &amp; -b &amp; b &amp; -c
\end{bmatrix}=
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix}
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A^T=
\begin{bmatrix}
 a &amp; b &amp; a &amp; c  \\\
 a &amp; c &amp; -a &amp; -b \\\
 a &amp; -c &amp; -a &amp; b \\\
 a &amp; -b &amp; a &amp; -c
\end{bmatrix}=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code&gt;这里两个[]之间是矩阵相乘的关系
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       我们可以把DCT变换写成下式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=AXA^T=
\begin{bmatrix}
 a &amp; a &amp; a &amp; a\\\
 b &amp; c &amp; -c &amp;-b \\\
 a &amp; -a &amp; -a &amp; a \\\
 c &amp; -b &amp; b &amp; -c
\end{bmatrix}
[X]
\begin{bmatrix}
 a &amp; b &amp; a &amp; c  \\\
 a &amp; c &amp; -a &amp; -b \\\
 a &amp; -c &amp; -a &amp; b \\\
 a &amp; -b &amp; a &amp; -c
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code&gt;三个矩阵相乘，就是DCT转换的公式 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;$Y=C_f * X * C_f^t&lt;/script&gt;$&lt;/p&gt;

&lt;p&gt;       为了保证正交，a,b,c,d取值如下&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a=\frac{1}{2},b=\sqrt{\frac{1}{2}}cos \left( \frac{\pi}{8} \right),c=\sqrt{\frac{1}{2}}cos \left( frac{3\pi}{8} \right),d=\frac{c}{b}&lt;/script&gt;

&lt;p&gt;       DCT变换公式可改为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix}
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       把两边的对称矩阵移到左边可得：(对角阵移项)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 a^{-1} &amp;   &amp;   &amp;  \\\
   &amp; b^{-1} &amp;   &amp;  \\\
   &amp;   &amp; a^{-1} &amp;  \\\
   &amp;   &amp;   &amp; b^{-1}
\end{bmatrix}
[Y]
\begin{bmatrix}
 a^{-1} &amp;   &amp;   &amp;  \\\
   &amp; b^{-1} &amp;   &amp;  \\\
   &amp;   &amp; a^{-1} &amp;  \\\
   &amp;   &amp;   &amp; b^{-1}
\end{bmatrix}= \\\
Y\otimes
\begin{bmatrix}
 a^{-2} &amp; (ab)^{-1}  &amp; a^{-2}  &amp; (ab)^{-1} \\\
 (ab)^{-1}  &amp; b^{-2} &amp; (ab)^{-1}  &amp; b^{-2} \\\
 a^{-2} &amp; (ab)^{-1}  &amp; a^{-2}  &amp; (ab)^{-1} \\\
 (ab)^{-1}  &amp; b^{-2} &amp; (ab)^{-1}  &amp; b^{-2}
\end{bmatrix}=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       再移项变形可得：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\otimes
\begin{bmatrix}
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab &amp; b^2 \\\
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab  &amp; b^2
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       此时，d的值为0.4142。这样的话，还是实数运算。如我们令&lt;script type=&quot;math/tex&quot;&gt;$d=\frac{1}{2}&lt;/script&gt;$,则&lt;script type=&quot;math/tex&quot;&gt;$b=\sqrt{\frac{2}{5}}&lt;/script&gt;$,
&lt;script type=&quot;math/tex&quot;&gt;$c=\sqrt{\frac{1}{10}}&lt;/script&gt;$,同样，可以保证矩阵的正交，同时，可以把运算变为整数运算。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=\left( 
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; \frac{1}{2} &amp; -\frac{1}{2} &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 \frac{1}{2} &amp; -1 &amp; 1 &amp; -\frac{1}{2}
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; \frac{1}{2}\\\
 1 &amp; \frac{1}{2} &amp; -1 &amp; -1 \\\
 1 &amp; -\frac{1}{2} &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -\frac{1}{2}
\end{bmatrix}
\right)
\otimes
\begin{bmatrix}
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab &amp; b^2 \\\
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab   &amp; b^2
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;把&lt;script type=&quot;math/tex&quot;&gt;$\frac{1}{2}&lt;/script&gt;$提到矩阵之外，并与右边的矩阵点乘合并，得:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=(C_fXC_f^T)\otimes E_f 
\\\=
\left(
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix}
\right)
\otimes
\begin{bmatrix}
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2} &amp; \frac{b^2}{4}\\\
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2}   &amp; \frac{b^2}{4}
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       其中，&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
C_f=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix},
E_f=
\begin{bmatrix}
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2} &amp; \frac{b^2}{4}\\\
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2}   &amp; \frac{b^2}{4}
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       在H264编码的JM编码器中，变换只包括：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       后面的点乘实际上是在量化过程中进行，因为后面的点乘还有实数运算，实数运算将不可避免地产生精度误差,而且运算量巨大。而量化本身就会丢失一些信号，因些，这些实数运算放在量化过程中将大大的降低变换的运算率同时又不明显影响精度？[博主sno的解释: 之所有把后面的Ef和这里分割开，是因为在转换和量化这一步，不可避免的会遇到乘法操作，这里说的只用加减和移位操作，是在这三个矩阵乘法大数据量运算之间只使用加减和移位，可以把64次的乘法运算转为只有两次的乘法运算，极大的减少消耗，在量化的时候，再对每个W[i][j]分别进行乘法操作。]&lt;/p&gt;

&lt;p&gt;       然而，4X4的矩阵运算如果按常规算法的话仍要进行64次乘法运算和48次加法，这将耗费较多的时间，于是在H.264中，有一种改进的算法（蝶形算法）可以减少运算的次数。这种矩阵运算算法构造非常巧妙，利用构造的矩阵的整数性质和对称性，可完全将乘法运算转化为加法运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.163.com/photo/-IW9juRdL0FtEDdpN6KBXQ==/1183883752046274032.jpg&quot; alt=&quot;蝶形运算示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;变换过程在JM编码器中的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//  Horizontal transform水平变换，其实就是左乘Cf,
&lt;/code&gt;&lt;/pre&gt;

  	for (j=0; j &amp;lt; BLOCK_SIZE &amp;amp;&amp;amp; !lossless_qpprime; j++)

  	{

&lt;pre&gt;&lt;code&gt;        for (i=0; i &amp;lt; 2; i++)

{

  i1=3-i;

  m5[i]=img-&amp;gt;m7[i][j]+img-&amp;gt;m7[i1][j];

  m5[i1]=img-&amp;gt;m7[i][j]-img-&amp;gt;m7[i1][j];

}

img-&amp;gt;m7[0][j]=(m5[0]+m5[1]);

img-&amp;gt;m7[2][j]=(m5[0]-m5[1]);

img-&amp;gt;m7[1][j]=m5[3]*2+m5[2];

img-&amp;gt;m7[3][j]=m5[3]-m5[2]*2;
&lt;/code&gt;&lt;/pre&gt;

  	}

  	//  Vertical transform垂直变换，其实就是右乘CfT

  	for (i=0; i &amp;lt; BLOCK_SIZE &amp;amp;&amp;amp; !lossless_qpprime; i++)

  	{

&lt;pre&gt;&lt;code&gt;        for (j=0; j &amp;lt; 2; j++)

{

  j1=3-j;

  m5[j]=img-&amp;gt;m7[i][j]+img-&amp;gt;m7[i][j1];

  m5[j1]=img-&amp;gt;m7[i][j]-img-&amp;gt;m7[i][j1];

}

img-&amp;gt;m7[i][0]=(m5[0]+m5[1]);

img-&amp;gt;m7[i][2]=(m5[0]-m5[1]);

img-&amp;gt;m7[i][1]=m5[3]*2+m5[2];

img-&amp;gt;m7[i][3]=m5[3]-m5[2]*2;
&lt;/code&gt;&lt;/pre&gt;

  	}

&lt;h3 id=&quot;section-1&quot;&gt;分析该蝶形算法&lt;/h3&gt;

&lt;p&gt;       上面的JM代码就是计算下面三个4x4矩阵的过程。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       分析一下前两个矩阵的乘法，只分析他们结果矩阵的第一行。有什么办法可以减少运算量呢？首先采用传统方法计算，得到结果：&lt;/p&gt;

&lt;p&gt;X[0] = x[00]+x[10]+x[20]+x[30]&lt;/p&gt;

&lt;p&gt;X[1] = 2 * x[00]+x[10]-x[20]-2 * x[30]&lt;/p&gt;

&lt;p&gt;X[2]= x[00]-x[10]-x[20]+x[30]&lt;/p&gt;

&lt;p&gt;X[3] = x[00]-2x[10]+2x[20]-x[30]&lt;/p&gt;

&lt;p&gt;       计算代价是16次乘法12次加法，考虑到矩阵的1的乘法可以省略，去除8个乘1，还需要8次乘法和12次加法。那么我们再仔细思考他们的相关性，从一般算法意义上来说，可以用空间代价换时间代价，比如设置中间变量来减少计算次数。用不同的颜色把需要重复运算的部分标上，作为中间变量。&lt;/p&gt;

&lt;p&gt;X[0] = &lt;font color=&quot;green&quot;&gt;x[00]&lt;/font&gt;+&lt;font color=&quot;blue&quot;&gt;x[10]&lt;/font&gt;+&lt;font color=&quot;blue&quot;&gt;x[20]&lt;/font&gt;+&lt;font color=&quot;green&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[1] = &lt;font color=&quot;purple&quot;&gt;2 * x[00]&lt;/font&gt;+x[10]-x[20]-2 * &lt;font color=&quot;purple&quot;&gt;2 * x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[2]= &lt;font color=&quot;green&quot;&gt;x[00]&lt;/font&gt;-&amp;lt;/font&amp;gt;+&lt;font color=&quot;blue&quot;&gt;x[10]&lt;/font&gt;-&lt;font color=&quot;blue&quot;&gt;x[20]&lt;/font&gt;+&lt;font color=&quot;green&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[3] = &lt;font color=&quot;purple&quot;&gt;x[00]&lt;/font&gt;-2x[10]+2x[20]-&lt;font color=&quot;purple&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;那么提取出来的中间变量将是：&lt;/p&gt;

&lt;font color=&quot;green&quot;&gt;x[00]+x[30]&lt;/font&gt;

&lt;font color=&quot;purple&quot;&gt;x[00]-x[30]&lt;/font&gt;

&lt;font color=&quot;blue&quot;&gt;x[10]+x[20]&lt;/font&gt;

&lt;p&gt;x[10]-x[20]&lt;/p&gt;

&lt;p&gt;       存储了这四个中间变量，我们对比看看蝶形图，和图中第一层的算式相符合。用这些中间变量来组合，就可以把最终的X[0]..X[3], 计算出来。这样，就把运算量降低到2个乘法和8个加法，剩余的运算就是叠代这个算法。&lt;/p&gt;

&lt;p&gt;       所以，可以得出以下结论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;这个蝶形图和一般意义的FFT或FDCT蝶形图不同，是对H.264在整数DCT基础上的具体算法优化，只对于以上Cf矩阵。&lt;/li&gt;
  &lt;li&gt;计算过程是把上面的三个4x4矩阵乘法分成两两矩阵相乘。再把残差矩阵和后来的中间结果Cf x X一行行分别输入蝶形图进行一维整数DCT计算。&lt;/li&gt;
  &lt;li&gt;蝶形图优化思想就是提取矩阵的相关部分，定义中间变量，减少运算次数。［sno博主添加：这里很重要，之所以使用蝶形算法，就是统计一下多次运行的规律，不重复计算相关的量。］&lt;/li&gt;
  &lt;li&gt;sno: 矩阵相乘 A*B   就是把A矩阵当前元素所在的这一行乘以B矩阵当前元素所在的这一列。代码实现如下&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;
	int  matrix_multiply(int a[4][4],int b[4][4],int c[4][4])
	{
		int
    	int i,j,k;
    	for(i=0;i&amp;lt;4;i++)
            for(j=0;j&amp;lt;4;j++)
            {
            	c[i][j]=0;
                for(k=0;k&amp;lt;4;k++)
                	c[i][j]+=a[i][k]*b[k][j];  ///c[i][j]=a的i这一行*b的j这一列的总和 ,这里是累计和                          
            }
        return 0;        
	} 
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Thu, 07 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/07/h264_dctmd.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/07/h264_dctmd.html</guid>
        
        <category>数字图像处理</category>
        
        <category>离散余弦变换</category>
        
        <category>蝶形运算</category>
        
        
        <category>数字图像处理</category>
        
      </item>
    
      <item>
        <title>数字图像处理-傅里叶变换,离散余弦变换</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;1.傅里叶变换&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.1. 一维离散傅里叶变换&lt;/h3&gt;
&lt;p&gt;       定义:设&lt;script type=&quot;math/tex&quot;&gt;${ f(n)|n=0,..,N-1}&lt;/script&gt;$为一维信号的N个采样值,其离散傅立叶变换及其逆变换分别为:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F(u)=\frac{1}{N}\sum_{k=0}^{N-1}f(k)e^{-j2\pi\frac{uk}{N}},u=0,1,\dots,N-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(k)=\sum_{u=0}^{N-1}F(u)e^{j2\pi\frac{uk}{N}},k=0,1,\dots,N-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
缩写 W= e^{\frac{-j2\pi}{N}}
\begin{matrix}
W^0 = 1 &amp; W^1=\frac{1-j}{\sqrt{2}} \\\
W^2 = -j &amp; W^3=\frac{-1-j}{\sqrt{2}} \\\
W^4 = -1 &amp; W^5=\frac{-1+j}{\sqrt{2}} \\\
W^6 = j &amp; W^7=\frac{1+j}{\sqrt{2}}
\end{matrix} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.2. 二维离散傅里叶变换&lt;/h3&gt;
&lt;p&gt;       定义:设&lt;script type=&quot;math/tex&quot;&gt;${f(x,y)|x=0,..,N-1, y=0,..,M-1}&lt;/script&gt;$为二维图像信号 其离散傅立叶变换及其逆变换分别为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F(u,v)=\frac{1}{\sqrt{MN}}\sum_{x=0}^{N-1}\sum\_{y=0}^{M-1}f(x,y)e^{-j2\pi(\frac{ux}{N}+\frac{vy}{M})},u=0,1,\dots,N-1,v=0,1,\dots,M-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x,y)=\frac{1}{\sqrt{MN}}\sum_{u=0}^{N-1}\sum\_{v=0}^{M-1}F(u,v)e^{j2\pi(\frac{ux}{N}+\frac{vy}{M})},u=0,1,\dots,N-1,v=0,1,\dots,M-1&lt;/script&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2. 快速傅里叶变换&lt;/h3&gt;
&lt;p&gt;       设&lt;script type=&quot;math/tex&quot;&gt;$N=2^L&lt;/script&gt;$(&lt;script type=&quot;math/tex&quot;&gt;$L&lt;/script&gt;$为正整数)。下面按照&lt;script type=&quot;math/tex&quot;&gt;$n&lt;/script&gt;$为奇数和偶数将序列&lt;script type=&quot;math/tex&quot;&gt;${f(n)}&lt;/script&gt;$进行划分，记为
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{cases}
g(n) &amp;= f(2n) \\\
h(n) &amp;= f(2n+1)
\end{cases}
\left ( n=0,1,2,\dots,\frac{N}{2}-1 \right ) %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;则离散傅里叶变换可以改写成下面的形式&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
F(m) &amp;= \sum_{n=0}^{N-1}f(n)W_N^mn \\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}f(2n)W_N^{m(2n)} + \sum\_{n=0}^{\frac{N}{2}-1}f(2n+1)W_N^{m(2n+1)}\\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}f(2n)W\_{\frac{N}{2}}^{mn} + \sum\_{n=0}^{\frac{N}{2}-1}f(2n+1)W\_{\frac{N}{2}}^{mn}W\_N^m\\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}g(n)W\_{\frac{N}{2}}^{mn} + W\_N^m\sum\_{n=0}^{\frac{N}{2}-1}h(n)W\_{\frac{N}{2}}^{mn}\\\
&amp;= G(m) + W\_N^mH(m)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;式中，&lt;script type=&quot;math/tex&quot;&gt;$G(m)&lt;/script&gt;$和&lt;script type=&quot;math/tex&quot;&gt;$H(m)&lt;/script&gt;$分别是&lt;script type=&quot;math/tex&quot;&gt;$g(n)&lt;/script&gt;$和&lt;script type=&quot;math/tex&quot;&gt;$h(n)&lt;/script&gt;$的离散傅里叶变换。一个长度为&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$的DFT可以转化为两个长度为&lt;script type=&quot;math/tex&quot;&gt;$\frac{N}{2}&lt;/script&gt;$的DFT。二维FFT可以由两次一维FFT得到。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3.关键算法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;private void setData1(Complex[] data, int power)
{
    this.power = power;

    //角度
    double angle;

    //计算FFT1变换的点数
    count = 1 &amp;lt;&amp;lt; power;

    //分配空间
    wc = new Complex[count / 2];
    x = new Complex[count];
    x1 = new Complex[count];
    x2 = new Complex[count];
    fd1 = new Complex[count];

    //初始化
    for (i = 0; i &amp;lt; count / 2; i++)
        wc[i] = new Complex();

    for (i = 0; i &amp;lt; count; i++)
    {
        x[i] = new Complex();
        x1[i] = new Complex();
        x2[i] = new Complex();
        fd1[i] = new Complex();
    }

    //计算加权系数
    for (i = 0; i &amp;lt; count / 2; i++)
    {
        angle = -i * Math.PI * 2 / count;
        wc[i].re = Math.cos(angle);
        wc[i].im = Math.sin(angle);
    }

    //将实域点写入x1
    for (i = 0; i &amp;lt; count; i++)
        x1[i] = data[i];
} 其中，$$$2^{power}=iw或ih$$$，与进行傅里叶变换是行或列有关，Complex表示复数。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;2.离散余弦变换&lt;/h2&gt;

&lt;h3 id=&quot;dft&quot;&gt;2.1.DFT存在的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DFT的参数都是复数,在数据的描述上相当于 实数的两倍。&lt;/li&gt;
  &lt;li&gt;为此,我们希望有一种能够达到相同功能但数 据量又不大的变换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dct-ii&quot;&gt;2.2.DCT-II公式&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_k = \sum_{n=0}^{N-1}x_ncos \left[ \frac{\pi}{N}\left( n+\frac{1}{2} \right) \right]&lt;/script&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.3.一维离散余弦变换&lt;/h3&gt;
&lt;p&gt;       一维&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$点离散余弦变换(DCT)可以表示为:
&lt;script type=&quot;math/tex&quot;&gt;y_k=C_k\sum_{n=0}^{N-1}x_ncos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;
其中，&lt;script type=&quot;math/tex&quot;&gt;$x_n&lt;/script&gt;$是输入时域序列中的第&lt;script type=&quot;math/tex&quot;&gt;$n&lt;/script&gt;$项，&lt;script type=&quot;math/tex&quot;&gt;$y_k&lt;/script&gt;$是输出频域序列中的第&lt;script type=&quot;math/tex&quot;&gt;$k&lt;/script&gt;$项，系数&lt;script type=&quot;math/tex&quot;&gt;$C_k&lt;/script&gt;$定义如下:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
C_k=
\begin{cases}
   \sqrt{\frac{1}{N}} &amp;\mbox{ $k=0$ }\\\
   \sqrt{\frac{2}{N}} &amp;\mbox{ $k=1,2,\dots,N-1$ }
   \end{cases} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;       一维&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$点离散余弦逆变换(IDCT)可以表示为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_n=\sum\_{k=0}^{N-1}C_ky_kcos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.4.二维离散余弦变换&lt;/h3&gt;
&lt;p&gt;       二维图像&lt;script type=&quot;math/tex&quot;&gt;$N\times N&lt;/script&gt;$图像块的DCT可以理解为对图像块的每一列进行一维DCT，然后对进行变换的块每列再做一维DCT。表达式如下所示：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Y_{mn}=C_mC_n\sum\_{i=0}^{N-1}\sum\_{j=0}^{N-1}X\_{ij}cos\frac{(2j+1)n\pi}{2N}cos\frac{(2i+1)m\pi}{2N}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_{ij}=\sum\_{i=0}^{N-1}\sum\_{j=0}^{N-1}C_mC_nY\_{mn}cos\frac{(2j+1)n\pi}{2N}cos\frac{(2i+1)m\pi}{2N}&lt;/script&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.5.关键算法&lt;/h3&gt;
&lt;p&gt;       求变换矩阵&lt;script type=&quot;math/tex&quot;&gt;$A&lt;/script&gt;$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void coeff(double[][] dct_coef, int n)
	{
    double sqrt_1 = 1.0 / Math.sqrt(2.0);

    for (int i = 0; i &amp;lt; n; i++)
        dct_coef[0][i] = sqrt_1;

    //初始化DCT系数
    for (int i = 1; i &amp;lt; n; i++)
        for (int j = 0; j &amp;lt; n; j++)
            dct_coef[i][j] = Math.cos(i * Math.PI * (j + 0.5) /((double)n));
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       DCT正变换&lt;script type=&quot;math/tex&quot;&gt;$Y=AXA^T&lt;/script&gt;$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void dct(double[][] a, double[][] b, double[][] c, int n)
{
    double x;
    double[][] af = new double[n][n];
	for (int i = 0; i &amp;lt; n; i++)
    {
        for (int j = 0; j &amp;lt; n; j++)
        {
            x = 0.0;
            for (int k = 0; k &amp;lt; n; k++)
                x += a[i][k] * b[k][j];
            af[i][j] = x;
        }
    }
    for (int i = 0; i &amp;lt; n; i++)
    {
        for (int j = 0; j &amp;lt; n; j++)
        {
            x = 0.0;
            for (int k = 0; k &amp;lt; n; k++)
                x += c[i][k] * af[k][j];
            a[i][j] = 2.0 * x / ((double)n);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;script type=&quot;math/tex&quot;&gt;$a,b,c&lt;/script&gt;$矩阵分别为被变换的矩阵&lt;script type=&quot;math/tex&quot;&gt;$X&lt;/script&gt;$,变换矩阵的转置&lt;script type=&quot;math/tex&quot;&gt;$A^T&lt;/script&gt;$,变换矩阵&lt;script type=&quot;math/tex&quot;&gt;$A&lt;/script&gt;$&lt;/p&gt;
</description>
        <pubDate>Tue, 05 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post02.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post02.html</guid>
        
        <category>数字图像处理</category>
        
        <category>傅里叶变换</category>
        
        <category>离散余弦变换</category>
        
        
        <category>数字图像处理</category>
        
      </item>
    
  </channel>
</rss>
