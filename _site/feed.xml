<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>菊长的菊花田</title>
    <description>菊长就是我，我就是菊长.</description>
    <link>http://thisisagoodname.github.io//</link>
    <atom:link href="http://thisisagoodname.github.io//zfeed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 09 May 2015 13:13:38 +0800</pubDate>
    <lastBuildDate>Sat, 09 May 2015 13:13:38 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>MMD4Mecanim系统研究(一)</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.bootcss.com/highlight.js/8.5/styles/monokai_sublime.min.css&quot; /&gt;
&lt;script src=&quot;http://cdn.bootcss.com/highlight.js/8.5/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://cdn.bootcss.com/highlight.js/8.5/languages/cpp.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
hljs.tabReplace = &#39; &#39;;
hljs.initHighlightingOnLoad();
&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;MathJax.Hub.Config({tex2jax:{inlineMath:[[&#39;$$$&#39;,&#39;$$$&#39;]]}});&lt;/script&gt;
&lt;script src=&quot;http://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;pmxu3dvmd&quot;&gt;1.PMX导入U3D引擎,并导入VMD动画&lt;/h2&gt;

&lt;h3 id=&quot;mmd4mecanim&quot;&gt;1.1导入MMD4Mecanim插件&lt;/h3&gt;

&lt;p&gt;       MMD4Mecanim是一个免费插件，&lt;a href=&quot;http://stereoarts.jp/&quot;&gt;官网&lt;/a&gt;，MMD4Mecanim的开发，截止本文写作，已经更新到MMD4Mecanim_Beta_20150508版本，本文也是以该版本进行演示。(而且截止到本文写作时，PMX2FBX已经有提取出来作为U3D独立插件的版本，我将会在日后写篇文章写依靠该插件将PMX文件和贴图都完整导入maya软件，并输出减面和贴图整合的FBX文件的文章。)MMD4Mecanim插件官方并没有指定需要的U3D版本，但使用了dll插件功能(以DLL插件的形式提供bullet物理引擎)，这个过去只有unity pro版才有，为了安全，我使用Unity3D 5.0.0f4 pro版做演示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-1@2x.png&quot; alt=&quot;导入MMD4Mecanim插件&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       进度条成功读完，no error no warning(U3D5导入15年3月更新更早版本的MMD4Mecanim也许会有问题,用4.6.3的请无视)，project目录下，有了三个文件夹，分别是BulletXNA，MMD4Mecanim，Plugins。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1.2导入模型文件&lt;/h3&gt;

&lt;p&gt;       把自己珍藏的PMX文件整个文件夹拖到project窗口，或者手动复制到项目文件夹的Assets文件夹下。我使用的是百度贴吧iRon0129大神制作的Tda Uniform Haku模型作为演示，如果侵犯了您的权利，也请通知我，我会马上修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-2@2x.png&quot; alt=&quot;导入后状态&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       MMD4Mecanim会在每个PMX文件下面生成一个文件。选择这个文件，会看到作者的声明，还有新添加的MMD3Mecanim的道德提示。(绝大多数模型作者都会反对二次配布以及商业用途)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-3@2x.png&quot; alt=&quot;模型声明1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       点击同意后，进入如下所示界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-4@2x.png&quot; alt=&quot;模型声明2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;vmd&quot;&gt;1.3添加VMD动作&lt;/h3&gt;

&lt;p&gt;       跟导入PMX文件相同，把VMD文件拖到project窗口，或者复制到Assets文件夹下，我新建了一个VMD_File文件夹，让整个工程看起来整齐。(每个VMD都是有声明的，不会提示，但需要开发者资深自重，该VMD的作者，如果我侵犯了您的权利，也请通知我)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-5@2x.png&quot; alt=&quot;VMD文件导入&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       把VMD文件拖拽到VMD条目下，如果需要添加多个，则需要重复多次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-6@2x.png&quot; alt=&quot;VMD文件导入2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       然后点击process即可，需要稍微等一会，这次不会有进度提示了，别误认为死机了或者U3D挂了，是在处理，添加的VMD之后会添加到FBX动画中。&lt;/p&gt;

&lt;p&gt;       成功之后，FBX文件出现，几个添加的VMD动画已经添加到FBX中，而且切段已经切好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-7@2x.png&quot; alt=&quot;导入成功演示&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       将生成的FBX拖入到场景中，可以看到模型和贴图都加载的非常好，材质丢失现象也没有发生。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-8@2x.png&quot; alt=&quot;拖入场景演示&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       然后把FBX中的动画拖拽到模型上，生成Animation Controller，并添加到模型上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/QQ20150509-8@2x.png&quot; alt=&quot;FBX添加动画&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       再点击运行，即可看到效果.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MMD4Mecanim/MMD4Mecanim-VMD.gif&quot; alt=&quot;最终动态效果&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd.html</guid>
        
        <category>Unity3D</category>
        
        <category>MMD4Mecanim</category>
        
        
        <category>unity3d</category>
        
      </item>
    
      <item>
        <title>数字图像处理-离散余弦变换的蝶形运算</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.bootcss.com/highlight.js/8.5/styles/monokai_sublime.min.css&quot; /&gt;

&lt;script src=&quot;http://cdn.bootcss.com/highlight.js/8.5/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;http://cdn.bootcss.com/highlight.js/8.5/languages/cpp.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
hljs.tabReplace = &#39; &#39;;
hljs.initHighlightingOnLoad();
&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;MathJax.Hub.Config({tex2jax:{inlineMath:[[&#39;$$$&#39;,&#39;$$$&#39;]]}});&lt;/script&gt;
&lt;script src=&quot;http://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;p&gt;转自&lt;a href=&quot;http://blog.csdn.net/sno_guo/article/details/8039659&quot;&gt;http://blog.csdn.net/sno_guo/article/details/8039659&lt;/a&gt;,并自己做了一些内容上的删减。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;为什么要进行变换&lt;/h3&gt;

&lt;p&gt;       空间图像数据通常是很难压缩的：相邻的采样点具有很强的相关性（相互关联的），而且能量一般平均分布在一幅图像中，从而要想丢掉某些数据和降低数据精度而不明显影响图像质量，就要选择合适的变换，方法，使图像易于被压缩。适合压缩的变换方法要有这样几个性质：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.可以聚集图像的能量（将能量集中到少数有意义的数值上）；如下图：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.163.com/photo/QNUqLLTRxzhgqpkFYPQY3w==/1183883752046274017.jpg&quot; alt=&quot;三维DCT示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2.可以除去数据之间的相关性（以使丢掉不重要的数据对图像的质量影响很少）。&lt;/li&gt;
  &lt;li&gt;3.变换方法应该适合用软硬件实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dct&quot;&gt;DCT算法的实例&lt;/h3&gt;
&lt;p&gt;       H264视频压缩&lt;/p&gt;

&lt;h3 id=&quot;x4dct&quot;&gt;4x4整数DCT推导过程&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_k=C_k\sum_{n=0}^{N-1}x_ncos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;

&lt;p&gt;       将上面的DCT公式转变为矩阵公式，为了说明标准矩阵中整数的变换和反变换，先假设&lt;script type=&quot;math/tex&quot;&gt;$d=\frac{c}{b}&lt;/script&gt;$。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A=
\begin{bmatrix}
 a &amp; a &amp; a &amp; a\\\
 b &amp; c &amp; -c &amp;-b \\\
 a &amp; -a &amp; -a &amp; a \\\
 c &amp; -b &amp; b &amp; -c
\end{bmatrix}=
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix}
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A^T=
\begin{bmatrix}
 a &amp; b &amp; a &amp; c  \\\
 a &amp; c &amp; -a &amp; -b \\\
 a &amp; -c &amp; -a &amp; b \\\
 a &amp; -b &amp; a &amp; -c
\end{bmatrix}=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code&gt;这里两个[]之间是矩阵相乘的关系
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       我们可以把DCT变换写成下式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=AXA^T=
\begin{bmatrix}
 a &amp; a &amp; a &amp; a\\\
 b &amp; c &amp; -c &amp;-b \\\
 a &amp; -a &amp; -a &amp; a \\\
 c &amp; -b &amp; b &amp; -c
\end{bmatrix}
[X]
\begin{bmatrix}
 a &amp; b &amp; a &amp; c  \\\
 a &amp; c &amp; -a &amp; -b \\\
 a &amp; -c &amp; -a &amp; b \\\
 a &amp; -b &amp; a &amp; -c
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code&gt;三个矩阵相乘，就是DCT转换的公式 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;$Y=C_f * X * C_f^t&lt;/script&gt;$&lt;/p&gt;

&lt;p&gt;       为了保证正交，a,b,c,d取值如下&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a=\frac{1}{2},b=\sqrt{\frac{1}{2}}cos \left( \frac{\pi}{8} \right),c=\sqrt{\frac{1}{2}}cos \left( frac{3\pi}{8} \right),d=\frac{c}{b}&lt;/script&gt;

&lt;p&gt;       DCT变换公式可改为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix}
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       把两边的对称矩阵移到左边可得：(对角阵移项)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 a^{-1} &amp;   &amp;   &amp;  \\\
   &amp; b^{-1} &amp;   &amp;  \\\
   &amp;   &amp; a^{-1} &amp;  \\\
   &amp;   &amp;   &amp; b^{-1}
\end{bmatrix}
[Y]
\begin{bmatrix}
 a^{-1} &amp;   &amp;   &amp;  \\\
   &amp; b^{-1} &amp;   &amp;  \\\
   &amp;   &amp; a^{-1} &amp;  \\\
   &amp;   &amp;   &amp; b^{-1}
\end{bmatrix}= \\\
Y\otimes
\begin{bmatrix}
 a^{-2} &amp; (ab)^{-1}  &amp; a^{-2}  &amp; (ab)^{-1} \\\
 (ab)^{-1}  &amp; b^{-2} &amp; (ab)^{-1}  &amp; b^{-2} \\\
 a^{-2} &amp; (ab)^{-1}  &amp; a^{-2}  &amp; (ab)^{-1} \\\
 (ab)^{-1}  &amp; b^{-2} &amp; (ab)^{-1}  &amp; b^{-2}
\end{bmatrix}=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       再移项变形可得：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\otimes
\begin{bmatrix}
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab &amp; b^2 \\\
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab  &amp; b^2
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       此时，d的值为0.4142。这样的话，还是实数运算。如我们令&lt;script type=&quot;math/tex&quot;&gt;$d=\frac{1}{2}&lt;/script&gt;$,则&lt;script type=&quot;math/tex&quot;&gt;$b=\sqrt{\frac{2}{5}}&lt;/script&gt;$,
&lt;script type=&quot;math/tex&quot;&gt;$c=\sqrt{\frac{1}{10}}&lt;/script&gt;$,同样，可以保证矩阵的正交，同时，可以把运算变为整数运算。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=\left( 
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; \frac{1}{2} &amp; -\frac{1}{2} &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 \frac{1}{2} &amp; -1 &amp; 1 &amp; -\frac{1}{2}
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; \frac{1}{2}\\\
 1 &amp; \frac{1}{2} &amp; -1 &amp; -1 \\\
 1 &amp; -\frac{1}{2} &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -\frac{1}{2}
\end{bmatrix}
\right)
\otimes
\begin{bmatrix}
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab &amp; b^2 \\\
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab   &amp; b^2
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;把&lt;script type=&quot;math/tex&quot;&gt;$\frac{1}{2}&lt;/script&gt;$提到矩阵之外，并与右边的矩阵点乘合并，得:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=(C_fXC_f^T)\otimes E_f 
\\\=
\left(
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix}
\right)
\otimes
\begin{bmatrix}
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2} &amp; \frac{b^2}{4}\\\
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2}   &amp; \frac{b^2}{4}
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       其中，&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
C_f=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix},
E_f=
\begin{bmatrix}
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2} &amp; \frac{b^2}{4}\\\
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2}   &amp; \frac{b^2}{4}
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       在H264编码的JM编码器中，变换只包括：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       后面的点乘实际上是在量化过程中进行，因为后面的点乘还有实数运算，实数运算将不可避免地产生精度误差,而且运算量巨大。而量化本身就会丢失一些信号，因些，这些实数运算放在量化过程中将大大的降低变换的运算率同时又不明显影响精度？[博主sno的解释: 之所有把后面的Ef和这里分割开，是因为在转换和量化这一步，不可避免的会遇到乘法操作，这里说的只用加减和移位操作，是在这三个矩阵乘法大数据量运算之间只使用加减和移位，可以把64次的乘法运算转为只有两次的乘法运算，极大的减少消耗，在量化的时候，再对每个W[i][j]分别进行乘法操作。]&lt;/p&gt;

&lt;p&gt;       然而，4X4的矩阵运算如果按常规算法的话仍要进行64次乘法运算和48次加法，这将耗费较多的时间，于是在H.264中，有一种改进的算法（蝶形算法）可以减少运算的次数。这种矩阵运算算法构造非常巧妙，利用构造的矩阵的整数性质和对称性，可完全将乘法运算转化为加法运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.163.com/photo/-IW9juRdL0FtEDdpN6KBXQ==/1183883752046274032.jpg&quot; alt=&quot;蝶形运算示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;变换过程在JM编码器中的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//  Horizontal transform水平变换，其实就是左乘Cf,
&lt;/code&gt;&lt;/pre&gt;

  	for (j=0; j &amp;lt; BLOCK_SIZE &amp;amp;&amp;amp; !lossless_qpprime; j++)

  	{

&lt;pre&gt;&lt;code&gt;        for (i=0; i &amp;lt; 2; i++)

{

  i1=3-i;

  m5[i]=img-&amp;gt;m7[i][j]+img-&amp;gt;m7[i1][j];

  m5[i1]=img-&amp;gt;m7[i][j]-img-&amp;gt;m7[i1][j];

}

img-&amp;gt;m7[0][j]=(m5[0]+m5[1]);

img-&amp;gt;m7[2][j]=(m5[0]-m5[1]);

img-&amp;gt;m7[1][j]=m5[3]*2+m5[2];

img-&amp;gt;m7[3][j]=m5[3]-m5[2]*2;
&lt;/code&gt;&lt;/pre&gt;

  	}

  	//  Vertical transform垂直变换，其实就是右乘CfT

  	for (i=0; i &amp;lt; BLOCK_SIZE &amp;amp;&amp;amp; !lossless_qpprime; i++)

  	{

&lt;pre&gt;&lt;code&gt;        for (j=0; j &amp;lt; 2; j++)

{

  j1=3-j;

  m5[j]=img-&amp;gt;m7[i][j]+img-&amp;gt;m7[i][j1];

  m5[j1]=img-&amp;gt;m7[i][j]-img-&amp;gt;m7[i][j1];

}

img-&amp;gt;m7[i][0]=(m5[0]+m5[1]);

img-&amp;gt;m7[i][2]=(m5[0]-m5[1]);

img-&amp;gt;m7[i][1]=m5[3]*2+m5[2];

img-&amp;gt;m7[i][3]=m5[3]-m5[2]*2;
&lt;/code&gt;&lt;/pre&gt;

  	}

&lt;h3 id=&quot;section-1&quot;&gt;分析该蝶形算法&lt;/h3&gt;

&lt;p&gt;       上面的JM代码就是计算下面三个4x4矩阵的过程。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       分析一下前两个矩阵的乘法，只分析他们结果矩阵的第一行。有什么办法可以减少运算量呢？首先采用传统方法计算，得到结果：&lt;/p&gt;

&lt;p&gt;X[0] = x[00]+x[10]+x[20]+x[30]&lt;/p&gt;

&lt;p&gt;X[1] = 2 * x[00]+x[10]-x[20]-2 * x[30]&lt;/p&gt;

&lt;p&gt;X[2]= x[00]-x[10]-x[20]+x[30]&lt;/p&gt;

&lt;p&gt;X[3] = x[00]-2x[10]+2x[20]-x[30]&lt;/p&gt;

&lt;p&gt;       计算代价是16次乘法12次加法，考虑到矩阵的1的乘法可以省略，去除8个乘1，还需要8次乘法和12次加法。那么我们再仔细思考他们的相关性，从一般算法意义上来说，可以用空间代价换时间代价，比如设置中间变量来减少计算次数。用不同的颜色把需要重复运算的部分标上，作为中间变量。&lt;/p&gt;

&lt;p&gt;X[0] = &lt;font color=&quot;green&quot;&gt;x[00]&lt;/font&gt;+&lt;font color=&quot;blue&quot;&gt;x[10]&lt;/font&gt;+&lt;font color=&quot;blue&quot;&gt;x[20]&lt;/font&gt;+&lt;font color=&quot;green&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[1] = &lt;font color=&quot;purple&quot;&gt;2 * x[00]&lt;/font&gt;+x[10]-x[20]-2 * &lt;font color=&quot;purple&quot;&gt;2 * x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[2]= &lt;font color=&quot;green&quot;&gt;x[00]&lt;/font&gt;-&amp;lt;/font&amp;gt;+&lt;font color=&quot;blue&quot;&gt;x[10]&lt;/font&gt;-&lt;font color=&quot;blue&quot;&gt;x[20]&lt;/font&gt;+&lt;font color=&quot;green&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[3] = &lt;font color=&quot;purple&quot;&gt;x[00]&lt;/font&gt;-2x[10]+2x[20]-&lt;font color=&quot;purple&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;那么提取出来的中间变量将是：&lt;/p&gt;

&lt;font color=&quot;green&quot;&gt;x[00]+x[30]&lt;/font&gt;

&lt;font color=&quot;purple&quot;&gt;x[00]-x[30]&lt;/font&gt;

&lt;font color=&quot;blue&quot;&gt;x[10]+x[20]&lt;/font&gt;

&lt;p&gt;x[10]-x[20]&lt;/p&gt;

&lt;p&gt;       存储了这四个中间变量，我们对比看看蝶形图，和图中第一层的算式相符合。用这些中间变量来组合，就可以把最终的X[0]..X[3], 计算出来。这样，就把运算量降低到2个乘法和8个加法，剩余的运算就是叠代这个算法。&lt;/p&gt;

&lt;p&gt;       所以，可以得出以下结论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;这个蝶形图和一般意义的FFT或FDCT蝶形图不同，是对H.264在整数DCT基础上的具体算法优化，只对于以上Cf矩阵。&lt;/li&gt;
  &lt;li&gt;计算过程是把上面的三个4x4矩阵乘法分成两两矩阵相乘。再把残差矩阵和后来的中间结果Cf x X一行行分别输入蝶形图进行一维整数DCT计算。&lt;/li&gt;
  &lt;li&gt;蝶形图优化思想就是提取矩阵的相关部分，定义中间变量，减少运算次数。［sno博主添加：这里很重要，之所以使用蝶形算法，就是统计一下多次运行的规律，不重复计算相关的量。］&lt;/li&gt;
  &lt;li&gt;sno: 矩阵相乘 A*B   就是把A矩阵当前元素所在的这一行乘以B矩阵当前元素所在的这一列。代码实现如下&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;
	int  matrix_multiply(int a[4][4],int b[4][4],int c[4][4])
	{
		int
    	int i,j,k;
    	for(i=0;i&amp;lt;4;i++)
            for(j=0;j&amp;lt;4;j++)
            {
            	c[i][j]=0;
                for(k=0;k&amp;lt;4;k++)
                	c[i][j]+=a[i][k]*b[k][j];  ///c[i][j]=a的i这一行*b的j这一列的总和 ,这里是累计和                          
            }
        return 0;        
	} 
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Thu, 07 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/07/h264_dctmd.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/07/h264_dctmd.html</guid>
        
        <category>数字图像处理</category>
        
        <category>离散余弦变换</category>
        
        <category>蝶形运算</category>
        
        
        <category>数字图像处理</category>
        
      </item>
    
      <item>
        <title>数字图像处理-傅里叶变换,离散余弦变换</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.bootcss.com/highlight.js/8.5/styles/monokai_sublime.min.css&quot; /&gt;

&lt;script src=&quot;http://cdn.bootcss.com/highlight.js/8.5/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
hljs.tabReplace = &#39; &#39;;
hljs.initHighlightingOnLoad();
&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;MathJax.Hub.Config({tex2jax:{inlineMath:[[&#39;$$$&#39;,&#39;$$$&#39;]]}});&lt;/script&gt;
&lt;script src=&quot;http://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;section&quot;&gt;1.傅里叶变换&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.1. 一维离散傅里叶变换&lt;/h3&gt;
&lt;p&gt;       定义:设&lt;script type=&quot;math/tex&quot;&gt;${ f(n)|n=0,..,N-1}&lt;/script&gt;$为一维信号的N个采样值,其离散傅立叶变换及其逆变换分别为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F(u)=\frac{1}{N}\sum_{k=0}^{N-1}f(k)e^{-j2\pi\frac{uk}{N}},u=0,1,\dots,N-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(k)=\sum_{u=0}^{N-1}F(u)e^{j2\pi\frac{uk}{N}},k=0,1,\dots,N-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
缩写 W= e^{\frac{-j2\pi}{N}}
\begin{matrix}
W^0 = 1 &amp; W^1=\frac{1-j}{\sqrt{2}} \\\
W^2 = -j &amp; W^3=\frac{-1-j}{\sqrt{2}} \\\
W^4 = -1 &amp; W^5=\frac{-1+j}{\sqrt{2}} \\\
W^6 = j &amp; W^7=\frac{1+j}{\sqrt{2}}
\end{matrix} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.2. 二维离散傅里叶变换&lt;/h3&gt;
&lt;p&gt;       定义:设&lt;script type=&quot;math/tex&quot;&gt;${f(x,y)|x=0,..,N-1, y=0,..,M-1}&lt;/script&gt;$为二维图像信号 其离散傅立叶变换及其逆变换分别为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F(u,v)=\frac{1}{\sqrt{MN}}\sum_{x=0}^{N-1}\sum\_{y=0}^{M-1}f(x,y)e^{-j2\pi(\frac{ux}{N}+\frac{vy}{M})},u=0,1,\dots,N-1,v=0,1,\dots,M-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x,y)=\frac{1}{\sqrt{MN}}\sum_{u=0}^{N-1}\sum\_{v=0}^{M-1}F(u,v)e^{j2\pi(\frac{ux}{N}+\frac{vy}{M})},u=0,1,\dots,N-1,v=0,1,\dots,M-1&lt;/script&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2. 快速傅里叶变换&lt;/h3&gt;
&lt;p&gt;       设&lt;script type=&quot;math/tex&quot;&gt;$N=2^L&lt;/script&gt;$(&lt;script type=&quot;math/tex&quot;&gt;$L&lt;/script&gt;$为正整数)。下面按照&lt;script type=&quot;math/tex&quot;&gt;$n&lt;/script&gt;$为奇数和偶数将序列&lt;script type=&quot;math/tex&quot;&gt;${f(n)}&lt;/script&gt;$进行划分，记为
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{cases}
g(n) &amp;= f(2n) \\\
h(n) &amp;= f(2n+1)
\end{cases}
\left ( n=0,1,2,\dots,\frac{N}{2}-1 \right ) %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;则离散傅里叶变换可以改写成下面的形式&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
F(m) &amp;= \sum_{n=0}^{N-1}f(n)W_N^mn \\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}f(2n)W_N^{m(2n)} + \sum\_{n=0}^{\frac{N}{2}-1}f(2n+1)W_N^{m(2n+1)}\\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}f(2n)W\_{\frac{N}{2}}^{mn} + \sum\_{n=0}^{\frac{N}{2}-1}f(2n+1)W\_{\frac{N}{2}}^{mn}W\_N^m\\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}g(n)W\_{\frac{N}{2}}^{mn} + W\_N^m\sum\_{n=0}^{\frac{N}{2}-1}h(n)W\_{\frac{N}{2}}^{mn}\\\
&amp;= G(m) + W\_N^mH(m)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;式中，&lt;script type=&quot;math/tex&quot;&gt;$G(m)&lt;/script&gt;$和&lt;script type=&quot;math/tex&quot;&gt;$H(m)&lt;/script&gt;$分别是&lt;script type=&quot;math/tex&quot;&gt;$g(n)&lt;/script&gt;$和&lt;script type=&quot;math/tex&quot;&gt;$h(n)&lt;/script&gt;$的离散傅里叶变换。一个长度为&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$的DFT可以转化为两个长度为&lt;script type=&quot;math/tex&quot;&gt;$\frac{N}{2}&lt;/script&gt;$的DFT。二维FFT可以由两次一维FFT得到。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3.关键算法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;private void setData1(Complex[] data, int power)
{
    this.power = power;

    //角度
    double angle;

    //计算FFT1变换的点数
    count = 1 &amp;lt;&amp;lt; power;

    //分配空间
    wc = new Complex[count / 2];
    x = new Complex[count];
    x1 = new Complex[count];
    x2 = new Complex[count];
    fd1 = new Complex[count];

    //初始化
    for (i = 0; i &amp;lt; count / 2; i++)
        wc[i] = new Complex();

    for (i = 0; i &amp;lt; count; i++)
    {
        x[i] = new Complex();
        x1[i] = new Complex();
        x2[i] = new Complex();
        fd1[i] = new Complex();
    }

    //计算加权系数
    for (i = 0; i &amp;lt; count / 2; i++)
    {
        angle = -i * Math.PI * 2 / count;
        wc[i].re = Math.cos(angle);
        wc[i].im = Math.sin(angle);
    }

    //将实域点写入x1
    for (i = 0; i &amp;lt; count; i++)
        x1[i] = data[i];
} 其中，$$$2^{power}=iw或ih$$$，与进行傅里叶变换是行或列有关，Complex表示复数。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;2.离散余弦变换&lt;/h2&gt;

&lt;h3 id=&quot;dft&quot;&gt;2.1.DFT存在的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DFT的参数都是复数,在数据的描述上相当于 实数的两倍。&lt;/li&gt;
  &lt;li&gt;为此,我们希望有一种能够达到相同功能但数 据量又不大的变换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dct-ii&quot;&gt;2.2.DCT-II公式&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_k = \sum_{n=0}^{N-1}x_ncos \left[ \frac{\pi}{N}\left( n+\frac{1}{2} \right) \right]&lt;/script&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.3.一维离散余弦变换&lt;/h3&gt;
&lt;p&gt;       一维&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$点离散余弦变换(DCT)可以表示为:
&lt;script type=&quot;math/tex&quot;&gt;y_k=C_k\sum_{n=0}^{N-1}x_ncos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;
其中，&lt;script type=&quot;math/tex&quot;&gt;$x_n&lt;/script&gt;$是输入时域序列中的第&lt;script type=&quot;math/tex&quot;&gt;$n&lt;/script&gt;$项，&lt;script type=&quot;math/tex&quot;&gt;$y_k&lt;/script&gt;$是输出频域序列中的第&lt;script type=&quot;math/tex&quot;&gt;$k&lt;/script&gt;$项，系数&lt;script type=&quot;math/tex&quot;&gt;$C_k&lt;/script&gt;$定义如下:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
C_k=
\begin{cases}
   \sqrt{\frac{1}{N}} &amp;\mbox{ $k=0$ }\\\
   \sqrt{\frac{2}{N}} &amp;\mbox{ $k=1,2,\dots,N-1$ }
   \end{cases} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;       一维&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$点离散余弦逆变换(IDCT)可以表示为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_n=\sum\_{k=0}^{N-1}C_ky_kcos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.4.二维离散余弦变换&lt;/h3&gt;
&lt;p&gt;       二维图像&lt;script type=&quot;math/tex&quot;&gt;$N\times N&lt;/script&gt;$图像块的DCT可以理解为对图像块的每一列进行一维DCT，然后对进行变换的块每列再做一维DCT。表达式如下所示：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Y_{mn}=C_mC_n\sum\_{i=0}^{N-1}\sum\_{j=0}^{N-1}X\_{ij}cos\frac{(2j+1)n\pi}{2N}cos\frac{(2i+1)m\pi}{2N}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_{ij}=\sum\_{i=0}^{N-1}\sum\_{j=0}^{N-1}C_mC_nY\_{mn}cos\frac{(2j+1)n\pi}{2N}cos\frac{(2i+1)m\pi}{2N}&lt;/script&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.5.关键算法&lt;/h3&gt;
&lt;p&gt;       求变换矩阵&lt;script type=&quot;math/tex&quot;&gt;$A&lt;/script&gt;$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void coeff(double[][] dct_coef, int n)
	{
    double sqrt_1 = 1.0 / Math.sqrt(2.0);

    for (int i = 0; i &amp;lt; n; i++)
        dct_coef[0][i] = sqrt_1;

    //初始化DCT系数
    for (int i = 1; i &amp;lt; n; i++)
        for (int j = 0; j &amp;lt; n; j++)
            dct_coef[i][j] = Math.cos(i * Math.PI * (j + 0.5) /((double)n));
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       DCT正变换&lt;script type=&quot;math/tex&quot;&gt;$Y=AXA^T&lt;/script&gt;$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void dct(double[][] a, double[][] b, double[][] c, int n)
{
    double x;
    double[][] af = new double[n][n];
	for (int i = 0; i &amp;lt; n; i++)
    {
        for (int j = 0; j &amp;lt; n; j++)
        {
            x = 0.0;
            for (int k = 0; k &amp;lt; n; k++)
                x += a[i][k] * b[k][j];
            af[i][j] = x;
        }
    }
    for (int i = 0; i &amp;lt; n; i++)
    {
        for (int j = 0; j &amp;lt; n; j++)
        {
            x = 0.0;
            for (int k = 0; k &amp;lt; n; k++)
                x += c[i][k] * af[k][j];
            a[i][j] = 2.0 * x / ((double)n);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;script type=&quot;math/tex&quot;&gt;$a,b,c&lt;/script&gt;$矩阵分别为被变换的矩阵&lt;script type=&quot;math/tex&quot;&gt;$X&lt;/script&gt;$,变换矩阵的转置&lt;script type=&quot;math/tex&quot;&gt;$A^T&lt;/script&gt;$,变换矩阵&lt;script type=&quot;math/tex&quot;&gt;$A&lt;/script&gt;$&lt;/p&gt;
</description>
        <pubDate>Tue, 05 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post02.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post02.html</guid>
        
        <category>数字图像处理</category>
        
        <category>傅里叶变换</category>
        
        <category>离散余弦变换</category>
        
        
        <category>数字图像处理</category>
        
      </item>
    
      <item>
        <title>数字图像处理-直方图计算和灰度线性变换</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.bootcss.com/highlight.js/8.5/styles/monokai_sublime.min.css&quot; /&gt;

&lt;script src=&quot;http://cdn.bootcss.com/highlight.js/8.5/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
hljs.tabReplace = &#39; &#39;;
hljs.initHighlightingOnLoad();
&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;MathJax.Hub.Config({tex2jax:{inlineMath:[[&#39;$$$&#39;,&#39;$$$&#39;]]}});&lt;/script&gt;
&lt;script src=&quot;http://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;section&quot;&gt;1.图像的读取和显示&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.1图像的读取&lt;/h3&gt;
&lt;p&gt;        重点是使用awt的Image类,java本身支持jepg,gif和png三种图像格式。&lt;br /&gt;
        关键代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Image openImage(String is, MediaTracker tracker )
{
	Image im = null;
	//用MediaTracker跟踪图像加载
	im = Toolkit.getDefaultToolkit().getImage(is);
	tracker.addImage(im,0);

	//等待图像完成加载
	try	{ tracker.waitForID(0);	}
	catch(InterruptedException e){ e.printStackTrace();}
	return im;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.2图像的显示&lt;/h3&gt;
&lt;p&gt;        代码实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//显示两幅图与第2幅图像标题
//im   -- 输入图
//istr -- 输入图标题
//om   -- 输出图
//ostr -- 输出图标题
 
public void draw(Graphics g, Image im, String istr, Image om, String ostr)
{
    g.clearRect(0, 0, 530, 350);
    g.drawImage(im, 5,   50, null);
    g.drawImage(om, 270, 50, null);
    g.drawString(istr, 120, 320);
    g.drawString(ostr, 380, 320);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2.直方图的计算&lt;/h2&gt;
&lt;p&gt;        直方图的计算分别用&lt;script type=&quot;math/tex&quot;&gt;$w&lt;/script&gt;$和&lt;script type=&quot;math/tex&quot;&gt;$h&lt;/script&gt;$表示图像的宽度和高度。设灰度值&lt;script type=&quot;math/tex&quot;&gt;$ r_i&lt;/script&gt;$出现的频率为&lt;script type=&quot;math/tex&quot;&gt;$ n_i&lt;/script&gt;$，则&lt;strong&gt;直方图&lt;script type=&quot;math/tex&quot;&gt;$ H&lt;/script&gt;$&lt;/strong&gt;可用下式计算：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H(r_i)=\frac{n_i}{w\times h}&lt;/script&gt;

&lt;p&gt;        代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int[] getHist(int[] pix, int iw, int ih)
{
	int[] hist = new int[256];
    for(int i = 0; i &amp;lt; iw*ih; i++)
    {
        int grey = pix[i]&amp;amp;0xff;
        hist[grey]++;
    }
    return hist;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;3.灰度的线性变换&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;3.1彩色图像转变为灰度图像&lt;/h3&gt;
&lt;p&gt;        彩色图像转换为灰度图像的函数表达式如下：
&lt;script type=&quot;math/tex&quot;&gt;I=F(i,j)=\left \lfloor \frac{1}{3}(f_R(i,j)+f_G(i,j)+f_B(i,j)) \right \rfloor (i=0,1,···,M-1;j=0,1,···,N-1)&lt;/script&gt;
式中，记号&lt;script type=&quot;math/tex&quot;&gt;$\left \lfloor x \right \rfloor&lt;/script&gt;$表示不超过x的最大整数。利用上式求出&lt;script type=&quot;math/tex&quot;&gt;$I&lt;/script&gt;$值后，给输出图像的R、G、B分量都赋值&lt;script type=&quot;math/tex&quot;&gt;$I&lt;/script&gt;$，就能转变成灰度图像。&lt;br /&gt;
        代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//转变为灰度图像
public int[] toGray(int[] pix, int iw, int ih)
{
    ColorModel cm = ColorModel.getRGBdefault();
    int r, g, b, gray;

    for(int i = 0; i &amp;lt; iw*ih; i++)
    {
        r = cm.getRed(pix[i]);
        g = cm.getGreen(pix[i]);
        b = cm.getBlue(pix[i]);
        gray =(int)((r + g + b) / 3);
        pix[i] = 255 &amp;lt;&amp;lt; 24|gray &amp;lt;&amp;lt; 16|gray &amp;lt;&amp;lt; 8|gray;
    }
    return pix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;3.2图像的灰度线性变换&lt;/h3&gt;
&lt;p&gt;        记&lt;script type=&quot;math/tex&quot;&gt;$p&lt;/script&gt;$为变换的斜率，&lt;script type=&quot;math/tex&quot;&gt;$q&lt;/script&gt;$为截距，则灰度线性变换的数学公式如下：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
F(i,j)=
   \begin{cases}
   0 &amp;\mbox{ $f&#39;(i,j)&lt;0$ }\\\
   f&#39;(i,j) &amp;\mbox{ $0 \leq f&#39;(i,j) \leq 255$ }\\\
   255 &amp;\mbox{$f&#39;(i,j)&gt;255$ }
   \end{cases} %]]&gt;&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;f&#39;(i,j)=\left \lfloor p·f(i,j)+q \right \rfloor (i=0,1,···,M-1;j=0,1,···,N-1)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;        代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//线性变换
public int[] linetrans(int[] pix, int iw, int ih,float p, int q)
{
	ColorModel cm = ColorModel.getRGBdefault();
    int r, g, b;
	
	for(int i = 0; i &amp;lt; iw*ih; i++)
    {
        r = cm.getRed(pix[i]);
        g = cm.getGreen(pix[i]);
        b = cm.getBlue(pix[i]);

        //增加图像亮度
        r  = (int)(p * r + q);
        g  = (int)(p * g + q);
        b  = (int)(p * b + q);

        if(r &amp;gt;= 255)   r = 255;
        if(g &amp;gt;= 255)   g = 255;
        if(b &amp;gt;= 255)   b = 255;

        pix[i] = 255 &amp;lt;&amp;lt; 24|r &amp;lt;&amp;lt; 16|g &amp;lt;&amp;lt; 8|b;
    }
    return pix;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 05 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post01.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post01.html</guid>
        
        <category>数字图像处理</category>
        
        <category>图像直方图计算</category>
        
        <category>图像灰度拉伸</category>
        
        
        <category>数字图像处理</category>
        
      </item>
    
  </channel>
</rss>
