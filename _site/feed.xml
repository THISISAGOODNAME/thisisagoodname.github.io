<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>菊长的菊花田</title>
    <description>菊长就是我，我就是菊长.</description>
    <link>http://thisisagoodname.github.io//</link>
    <atom:link href="http://thisisagoodname.github.io//zfeed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 10 May 2015 12:56:51 +0800</pubDate>
    <lastBuildDate>Sun, 10 May 2015 12:56:51 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>MMD4Mecanim系统研究(三)</title>
        <description>&lt;h2 id=&quot;pmxu3dpmx2fbxpmxmaya&quot;&gt;PMX模型导入U3D使用,并使用PMX2FBX,对PMX模型完成转换，再导入到maya中,形成另外的工作流&lt;/h2&gt;

&lt;p&gt;       玩过unity和MMD的应该都知道MMD4Mecanim这个东东吧，几乎可以完美把PMX/PMD模型转成fbx导入unity。但是这个fbx不带贴图的，unity是通过对于的xml读取贴图，所以导入maya是一片灰色。
       网上能够较好应付PMD/PMX模型的也只有blender和C4D了，但blender操作和主流三维软件还是有些区别，而C4D的MMD tools总是丢材质球，简直蛋疼。
       转换之后，可以获得带贴图的FBX文件，再次导出的话，模型也&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;mmd4mecanim&quot;&gt;1.导入MMD4Mecanim插件，并导入模型&lt;/h3&gt;

&lt;p&gt;       导入模型的方法我在我的&lt;a href=&quot;./mmd4mecanimmd.html&quot;&gt;另一篇文章&lt;/a&gt;中已经详细的记录过了在此不再赘描述。&lt;/p&gt;

&lt;h3 id=&quot;mayammd4mecanimimport&quot;&gt;2.使用Maya的MMD4MecanimImport插件&lt;/h3&gt;

&lt;p&gt;       MMD4MecanimImport是博客园上一位叫做&lt;a href=&quot;http://home.cnblogs.com/u/marisa/&quot;&gt;高町☆魔理沙&lt;/a&gt;的大神制作的，&lt;a href=&quot;http://www.cnblogs.com/marisa/p/4131746.html&quot;&gt;原文链接&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;mayammd4mecanimfbx&quot;&gt;3.maya导入MMD4Mecanim生成的FBX&lt;/h3&gt;

&lt;p&gt;       安装完成MMD4MecanimImport插件之后，用该插件导入MMD4Mecanim转换的FBX模型。我用的是mac版的maya2014，MMD4Mecanim版本不能太新(15年4月版本以前的，估计是新版本修改的xml文件的一些细节，以后有机会研究maya脚本的话我会修改一下脚本文件)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101241316013571876338_001.jpg&quot; alt=&quot;导入到maya&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       导入完成，用着色模式查看一下(如果机子配置较低可以考虑用局部渲染看一下效果),然后选择导入的模型，再导出成fbx。保存，看到生成的fbx文件只有几M，相比过去的模型，连模型加贴图有几十M，小了很多。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;4.之后就可以用自己熟悉的工作流了&lt;/h3&gt;

&lt;p&gt;       我将模型导入到keyshot5中渲染一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101241316013571876338_000.jpg&quot; alt=&quot;导入到keyshot5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更多高级玩法可以去看魔理沙大神的博文原文&lt;/p&gt;

&lt;p&gt;PS:MMD4MecanimImport.py源代码如下，我做了微小的修改，使之在mac系统上使用稍微方便一些。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
import pymel.util.path as pmp
import maya.cmds as cmds
import maya.mel as mel
import maya.OpenMayaUI as OpenMayaUI
import shiboken
import os
import shutil
from PySide import QtGui, QtCore
from xml.dom.minidom import parse

class FBXExplorerQtWindow(QtGui.QMainWindow):
	def __init__(self,parent=None):
		super(FBXExplorerQtWindow,self).__init__(parent)
		self.setWindowTitle(&#39;MMD4Mecanim Import v0.1&#39;)
		self.resize( 800, 800 )
		
		widget = QtGui.QWidget()
		self.setCentralWidget(widget)
		
		mainLayout = QtGui.QVBoxLayout()
		widget.setLayout(mainLayout)
		
		self.line = QtGui.QLineEdit(self)
		self.fileBrowserWidget = QtGui.QWidget(self)
		self.dirModel = QtGui.QFileSystemModel()
		self.dirModel.setRootPath(&quot;~/Documents/&quot;)
		
		nameFilters = [&quot;*.fbx&quot;]
		self.dirModel.setNameFilters(nameFilters)
		self.dirModel.setNameFilterDisables(False)
		
		self.folderView = QtGui.QTreeView(parent=self)
		self.folderView.setModel(self.dirModel)
		self.folderView.clicked[QtCore.QModelIndex].connect(self.clicked) 
		self.folderView.doubleClicked[QtCore.QModelIndex].connect(self.doubleClicked) 
		
		self.folderView.setColumnWidth(0,250)
		
		mainLayout.addWidget(self.line,1,0)
		mainLayout.addWidget(self.folderView)

	def clicked(self,index):
		index = self.folderView.currentIndex()
		dirPath = pmp(self.dirModel.filePath(index))
		self.line.setText(dirPath.normpath())

	def doubleClicked(self,index):
		index = self.folderView.currentIndex()
		path = pmp(self.dirModel.filePath(index))
		self.openFile(path)

	def openFile(self,filePath):
		types = {&quot;.fbx&quot;:&quot;FBX&quot;}
		if filePath.ext.lower() not in types.keys():
			return
		fileType = types[filePath.ext.lower()]
		if fileType == &quot;FBX&quot;:
			nPos = filePath.rfind(&#39;/&#39;)
			dirPath = filePath[0:nPos+1]
			fileName = filePath[nPos+1:filePath.rfind(&#39;.&#39;)]
			fbxFileName = filePath[nPos+1:len(filePath)]
			xmlFileName = fileName + &#39;.xml&#39;
			xmlFilePath = dirPath + xmlFileName
			newDirPath = self.copyFileForMaya(fileName, filePath, xmlFilePath, dirPath)
			
			if os.path.exists(newDirPath):
				newFbxFilePath = newDirPath + fbxFileName
				newXmlFilePath = newDirPath + xmlFileName
				self.processRename(newFbxFilePath, newXmlFilePath)
				self.importFBXFile(newFbxFilePath)
				self.importTexture(newXmlFilePath, newDirPath)
				shutil.rmtree(newDirPath,True)
			return

	def copyFileForMaya(self, fbxFileName, fbxFilePath, xmlFilePath, dirPath):
		newDirName = &#39;.temp_&#39; + fbxFileName
		newDirPath = os.path.join(dirPath, newDirName)
		if not os.path.isdir(newDirPath):
			os.makedirs(newDirPath)
		
		newDirPath += &#39;/&#39;	
		if not os.path.exists(newDirPath):
			print newDirPath + &#39; does not exist!&#39;
			return &#39;&#39;
		
		shutil.copy(fbxFilePath, newDirPath)
		shutil.copy(xmlFilePath, newDirPath)
		return newDirPath

	def modify(self, filePath, sourceStr, targetStr):
		print &#39;modify &#39; + filePath + &#39; from &#39; + sourceStr + &#39; to &#39; + targetStr
		inputFile = open(filePath)
		lines = inputFile.readlines()
		inputFile.close()

		outputFile = open(filePath, &#39;w&#39;)
		for line in lines:
			if not line:
				break
			if sourceStr in line and not targetStr in line:
				nPos = line.find(sourceStr)
				temp1 = line[0:nPos]
				temp2 = line[nPos+len(sourceStr):len(line)]
				temp = temp1 + targetStr + temp2
				outputFile.write(temp)
			else:
				outputFile.write(line)

		outputFile.close()

	def formatName(self, name):
		newName = &#39;&#39;
		if &#39;.&#39; in name:
			nPos = name.find(&#39;.&#39;)
			newName = &#39;mat_&#39; + name[0:nPos]
		else:
			newName = &#39;mat_&#39; + name
		return newName
		
	def modifyMaterialName(self, fbxFilePath):
		inputFbxFile = open(fbxFilePath)
		inputFbxLines = inputFbxFile.readlines()
		inputFbxFile.close()
		outputFbxFile = open(fbxFilePath, &#39;w&#39;)
		tag1 = &#39;Material::&#39;
		tag2 = &#39;;Material::&#39;
		for line in inputFbxLines:
			if not line:
				break
			if tag2 in line:
				nPos1 = line.find(tag2)
				temp1 = line[0:nPos1]
				temp2 = line[nPos1+len(tag2):len(line)]
				nPos2 = temp2.find(&#39;, Model::&#39;)
				temp3 = temp2[nPos2:len(temp2)]
				materialName = self.formatName(temp2[0:nPos2])
				temp = temp1 + tag2 + materialName + temp3
				outputFbxFile.write(temp)
			elif tag1 in line:
				nPos1 = line.find(tag1)
				temp1 = line[0:nPos1]
				temp2 = line[nPos1+len(tag1):len(line)]
				nPos2 = temp2.find(&#39;&quot;&#39;)
				temp3 = temp2[nPos2:len(temp2)]
				materialName = self.formatName(temp2[0:nPos2])
				temp = temp1 + tag1 + materialName + temp3
				outputFbxFile.write(temp)
			else:
				outputFbxFile.write(line)
		outputFbxFile.close()
		
	def processRename(self, fbxFilePath, xmlFilePath):
		self.modifyMaterialName(fbxFilePath)
		self.modify(xmlFilePath, &#39;&lt;materialname&gt;&#39;, &#39;&lt;materialname&gt;mat_&#39;)
		self.modify(xmlFilePath, &#39;&lt;filename&gt;&#39;, &#39;&lt;filename&gt;../&#39;)
		print &#39;Material rename completed!&#39;

	def importFBXFile(self, filePath):
		nPos = filePath.rfind(&#39;/&#39;)
		fileName = filePath[nPos+1:filePath.rfind(&#39;.&#39;)]
		importedFile = cmds.file(filePath, i=True, type=&#39;FBX&#39;, ignoreVersion=True, ra=True, rdn=True, mergeNamespacesOnClash=False, namespace=fileName)
		print importedFile + &#39; import completed!&#39;
	
	def importTexture(self, filePath, dirPath):
		dom = parse(filePath)
		
		texFileNames = dom.getElementsByTagName(&quot;fileName&quot;)
		textures = []
		for i, texFileName in enumerate(texFileNames) :
			textures.append(dirPath.encode(&#39;shift-jis&#39;) + texFileName.childNodes[0].data.encode(&#39;shift-jis&#39;))
			if cmds.objExists(&#39;file&#39; + str(i+1)) :
				continue
			else:
				fileNode = cmds.shadingNode(&#39;file&#39;, asTexture=True)
				cmds.setAttr(fileNode + &#39;.fileTextureName&#39;, textures[i], type=&quot;string&quot;)
		print textures
		
		materialNames = dom.getElementsByTagName(&quot;materialName&quot;)	
		materialID = []
		for i, materialName in enumerate(materialNames) :
			materialID.append(materialName.childNodes[0].data)
		print materialID
		
		textureIDs = dom.getElementsByTagName(&quot;textureID&quot;)
		materialTexID = []
		for i, textureID in enumerate(textureIDs) :
			materialTexID.append(textureID.childNodes[0].data)
		print materialTexID
		
		for i, iMatID in enumerate(materialID) :
			iTexID = int(materialTexID[int(i)])+1
			if(iTexID &amp;lt;= 0):
				continue
			try:
				cmds.connectAttr(&#39;file%s.outColor&#39; %iTexID, &#39;%s.color&#39; %iMatID)
				print iMatID
			except:
				continue

def show_explorer(*args):
	ptr = OpenMayaUI.MQtUtil.mainWindow()
	widget = shiboken.wrapInstance(long(ptr),QtGui.QWidget)
	explorerWin = FBXExplorerQtWindow(widget)
	explorerWin.show()

def show_help(*args):
	cmds.confirmDialog(title = &quot;Help&quot;, message = &quot;\
Steps to import:\n\
1. Convert PMD/PMX file to FBX file in unity by using MMD4Mecanim.\n\
2. Click &#39;MMD4Mecanim Import&#39; to browse the FBX file of step1, double click to import.\n\
3. In MotionBuilder, click &#39;File/open&#39; to import the FBX file of step1 with default configuration (recommend to uncheck the material).\n\
4. In MotionBuilder, select the skeleton (or all the model) you imported at step3, click &#39;File/Send to Maya/Update Current Scene&#39;.\n\
\n\
Attention:\n\
1. The file name of fbx file and texture files should not be japanese or chinese.\n\
2. You can only import one model at a time, please save your model as the standard fbx file, then create a new scene to import another one.\n\
\n\
Enjoy! &amp;gt;_&amp;lt; \n\
\n\
Author: Takamachi Marisa\n\
Contact: http://weibo.com/u/2832212042&quot;,\
	icon = &quot;information&quot;)

def customMayaMenu():
	gMainWindow = mel.eval(&#39;$temp1=$gMainWindow&#39;)
	menus = cmds.window(gMainWindow, q = True, menuArray = True)
	found = False
	
	for menu in menus:
		label = cmds.menu(menu, q = True, label = True)
		if label == &quot;MMD4Mecanim Import&quot;:
			found = True
	
	if found == False:
		customMenu = cmds.menu(parent=gMainWindow, label = &#39;MMD4Mecanim Import&#39;)
		cmds.menuItem(parent = customMenu, label = &quot;Import MMD4Mecanim FBX&quot;, c = show_explorer)
		cmds.menuItem(parent = customMenu, label = &quot;Help&quot;, c = show_help)

# Initialize the plug-in
def initializePlugin(plugin):
	customMayaMenu()

# Uninitialize the plug-in
def uninitializePlugin(plugin):
	pass

&lt;/filename&gt;&lt;/filename&gt;&lt;/materialname&gt;&lt;/materialname&gt;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 10 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//unity3d/2015/05/10/mmd4mecanimmd3.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//unity3d/2015/05/10/mmd4mecanimmd3.html</guid>
        
        <category>Unity3D</category>
        
        <category>MMD4Mecanim</category>
        
        <category>maya</category>
        
        
        <category>unity3d</category>
        
      </item>
    
      <item>
        <title>MMD4Mecanim系统研究(二)</title>
        <description>&lt;h2 id=&quot;pmxu3dmecanim&quot;&gt;PMX模型导入U3D使用,并使用Mecanim动画系统,做一个小游戏&lt;/h2&gt;

&lt;h3 id=&quot;mmd4mecanim&quot;&gt;1.导入MMD4Mecanim插件，并导入模型&lt;/h3&gt;

&lt;p&gt;       导入模型的方法我在我的&lt;a href=&quot;./mmd4mecanimmd.html&quot;&gt;另一篇文章&lt;/a&gt;中已经详细的记录过了在此不再赘描述。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;characters&quot;&gt;2.导入Characters包&lt;/h3&gt;

&lt;p&gt;       具体操作为Assets-&amp;gt;Import Package-&amp;gt;Characters(Unity3D5.0不提供standard Assets，需要手动安装；Unity3D4.0和5.0standard Assets不同，U3D4.0是character controller)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_009.jpg&quot; alt=&quot;导入characters&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       点击Import之后，project窗口下自动生成了Standard Assets文件夹，并引入了Characters，CrossPlatform和Utility三个插件，这也是U3D5包管理的一个进步，在引入包的时候可以一定程度的分析依赖。&lt;/p&gt;

&lt;h3 id=&quot;mmdrighumanoid&quot;&gt;3.(关键)把导入的MMD模型的RIG属性改为Humanoid&lt;/h3&gt;

&lt;p&gt;       Mecanim动画系统对于人形动画提供了近乎于变态的强大支持，但使用人形动画的前提，就是模型的RIG必须调整为Humanoid(人形),在模型的inspector面板可以找到。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_008.jpg&quot; alt=&quot;RIG调整为Humanoid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       有时从原有谷歌转换为Humanoid骨骼并不完全成功，需要主动点击RIG面板下的…Configure…按钮，手动指定一下关节，之后点击Done确定，如下图所示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_007.jpg&quot; alt=&quot;手动指定关节&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;4.为转换好的模型添加动画控制器&lt;/h3&gt;

&lt;p&gt;       动画状态机可以自己写，时间所限，使用官方样例中的状态机，在project中的路径是Standard Assets/Characters/ThirdPersonCharacter/Animator/ThirdPersonAnimatorController，拖到模型的inspector面板，Animator的Controller下。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_006.jpg&quot; alt=&quot;添加动画控制器&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5.为模型添加自三人称控制脚本&lt;/h3&gt;

&lt;p&gt;       先在Hierarchy面板下选中模型，然后按Component-&amp;gt;Scripts-&amp;gt;UnityStandardAssets.Characters.ThirdPerson-&amp;gt;Third Person User Control,会自动把Third Person Character和 Third Person User Control Control两个脚本附加到模型上。如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_005.jpg&quot; alt=&quot;脚本附加到模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       然后编辑模型的Capusule Collider(胶囊体碰撞机
),最理想的状态是刚好把人物包住，胶囊体的中心也和人物模型正中心在一起。按Edit Collider可以进入手动修改模式，再按一次退出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_004.jpg&quot; alt=&quot;修改碰撞机&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       之后点击运行按钮，就可以看到很随意的站姿势了，恭喜，已经修改成功，按WSAD或者上下左右就可以控制人物移动了。记得一定要修改碰撞机(Collider)，不修改碰撞机的话，会产生模型悬空在场景之上的现象。中心选取不正确,或者碰撞机的底部和地面穿插，移动的时候会经常”蹲起”,也需要仔细修改一下。如果碰撞机总和地面穿插，可以考虑把模型沿Y周提升少许。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_003.gif&quot; alt=&quot;gameDemo1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;6.为模型添加摄像机追踪&lt;/h3&gt;

&lt;p&gt;       在Utility下找到SmoothFollow脚本，拖到Main Camera上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_002.jpg&quot; alt=&quot;SmoothFollow脚本&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       再把模型拖到脚本的Target上。记得修改Distance，Height和Rotation Damping三项，我的值是3、5、1，不配置Rotation Damping的话，摄像机不会旋转，效果并不好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_001.jpg&quot; alt=&quot;模型拖到脚本的Target上&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101240338727570561174_000.gif&quot; alt=&quot;gameDemo2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PS:最后说一下，如果之前记得打开了子弹物理引擎，那头发和衣服能看到很好的柔体运动效果，打开方法见我前一篇MMD4Mecanim的文章。&lt;/p&gt;
</description>
        <pubDate>Sat, 09 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd2.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd2.html</guid>
        
        <category>Unity3D</category>
        
        <category>MMD4Mecanim</category>
        
        
        <category>unity3d</category>
        
      </item>
    
      <item>
        <title>MMD4Mecanim系统研究(一)</title>
        <description>&lt;h2 id=&quot;pmxu3dvmd&quot;&gt;PMX导入U3D引擎,并导入VMD动画&lt;/h2&gt;

&lt;h3 id=&quot;mmd4mecanim&quot;&gt;1.导入MMD4Mecanim插件&lt;/h3&gt;

&lt;p&gt;       MMD4Mecanim是一个免费插件，&lt;a href=&quot;http://stereoarts.jp/&quot;&gt;官网&lt;/a&gt;，MMD4Mecanim的开发，截止本文写作，已经更新到MMD4Mecanim_Beta_20150508版本，本文也是以该版本进行演示。(而且截止到本文写作时，PMX2FBX已经有提取出来作为U3D独立插件的版本，我将会在日后写篇文章写依靠该插件将PMX文件和贴图都完整导入maya软件，并输出减面和贴图整合的FBX文件的文章。)MMD4Mecanim插件官方并没有指定需要的U3D版本，但使用了dll插件功能(以DLL插件的形式提供bullet物理引擎)，这个过去只有unity pro版才有，为了安全，我使用Unity3D 5.0.0f4 pro版做演示。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_009.jpg&quot; alt=&quot;导入MMD4Mecanim插件&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       进度条成功读完，no error no warning(U3D5导入15年3月更新更早版本的MMD4Mecanim也许会有问题,用4.6.3的请无视)，project目录下，有了三个文件夹，分别是BulletXNA，MMD4Mecanim，Plugins。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;2.导入模型文件&lt;/h3&gt;

&lt;p&gt;       把自己珍藏的PMX文件整个文件夹拖到project窗口，或者手动复制到项目文件夹的Assets文件夹下。我使用的是百度贴吧iRon0129大神制作的Tda Uniform Haku模型作为演示，如果侵犯了您的权利，也请通知我，我会马上修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_008.jpg&quot; alt=&quot;导入后状态&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       MMD4Mecanim会在每个PMX文件下面生成一个文件。选择这个文件，会看到作者的声明，还有新添加的MMD3Mecanim的道德提示。(绝大多数模型作者都会反对二次配布以及商业用途)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_007.jpg&quot; alt=&quot;模型声明1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       点击同意后，进入如下所示界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_006.jpg&quot; alt=&quot;模型声明2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;vmd&quot;&gt;3.添加VMD动作&lt;/h3&gt;

&lt;p&gt;       跟导入PMX文件相同，把VMD文件拖到project窗口，或者复制到Assets文件夹下，我新建了一个VMD_File文件夹，让整个工程看起来整齐。(每个VMD都是有声明的，不会提示，但需要开发者资深自重，该VMD的作者，如果我侵犯了您的权利，也请通知我)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_005.jpg&quot; alt=&quot;VMD文件导入&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       把VMD文件拖拽到VMD条目下，如果需要添加多个，则需要重复多次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_004.jpg&quot; alt=&quot;VMD文件导入2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       然后点击process即可，需要稍微等一会，这次不会有进度提示了，别误认为死机了或者U3D挂了，是在处理，添加的VMD之后会添加到FBX动画中。&lt;/p&gt;

&lt;p&gt;       成功之后，FBX文件出现，几个添加的VMD动画已经添加到FBX中，而且切段已经切好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_003.jpg&quot; alt=&quot;导入成功演示&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       将生成的FBX拖入到场景中，可以看到模型和贴图都加载的非常好，材质丢失现象也没有发生。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_002.jpg&quot; alt=&quot;拖入场景演示&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       然后把FBX中的动画拖拽到模型上，生成Animation Controller，并添加到模型上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_001.jpg&quot; alt=&quot;FBX添加动画&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       再点击运行，即可看到效果.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img17.poco.cn/mypoco/myphoto/20150510/12/178000492201505101239351775135402343_000.gif&quot; alt=&quot;最终动态效果&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//unity3d/2015/05/09/mmd4mecanimmd.html</guid>
        
        <category>Unity3D</category>
        
        <category>MMD4Mecanim</category>
        
        
        <category>unity3d</category>
        
      </item>
    
      <item>
        <title>数字图像处理-离散余弦变换的蝶形运算</title>
        <description>&lt;p&gt;转自&lt;a href=&quot;http://blog.csdn.net/sno_guo/article/details/8039659&quot;&gt;http://blog.csdn.net/sno_guo/article/details/8039659&lt;/a&gt;,并自己做了一些内容上的删减。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;为什么要进行变换&lt;/h3&gt;

&lt;p&gt;       空间图像数据通常是很难压缩的：相邻的采样点具有很强的相关性（相互关联的），而且能量一般平均分布在一幅图像中，从而要想丢掉某些数据和降低数据精度而不明显影响图像质量，就要选择合适的变换，方法，使图像易于被压缩。适合压缩的变换方法要有这样几个性质：&lt;/p&gt;

&lt;!-- more --&gt;

&lt;ul&gt;
  &lt;li&gt;1.可以聚集图像的能量（将能量集中到少数有意义的数值上）；如下图：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.163.com/photo/QNUqLLTRxzhgqpkFYPQY3w==/1183883752046274017.jpg&quot; alt=&quot;三维DCT示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2.可以除去数据之间的相关性（以使丢掉不重要的数据对图像的质量影响很少）。&lt;/li&gt;
  &lt;li&gt;3.变换方法应该适合用软硬件实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dct&quot;&gt;DCT算法的实例&lt;/h3&gt;
&lt;p&gt;       H264视频压缩&lt;/p&gt;

&lt;h3 id=&quot;x4dct&quot;&gt;4x4整数DCT推导过程&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_k=C_k\sum_{n=0}^{N-1}x_ncos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;

&lt;p&gt;       将上面的DCT公式转变为矩阵公式，为了说明标准矩阵中整数的变换和反变换，先假设&lt;script type=&quot;math/tex&quot;&gt;$d=\frac{c}{b}&lt;/script&gt;$。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A=
\begin{bmatrix}
 a &amp; a &amp; a &amp; a\\\
 b &amp; c &amp; -c &amp;-b \\\
 a &amp; -a &amp; -a &amp; a \\\
 c &amp; -b &amp; b &amp; -c
\end{bmatrix}=
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix}
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A^T=
\begin{bmatrix}
 a &amp; b &amp; a &amp; c  \\\
 a &amp; c &amp; -a &amp; -b \\\
 a &amp; -c &amp; -a &amp; b \\\
 a &amp; -b &amp; a &amp; -c
\end{bmatrix}=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code&gt;这里两个[]之间是矩阵相乘的关系
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       我们可以把DCT变换写成下式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=AXA^T=
\begin{bmatrix}
 a &amp; a &amp; a &amp; a\\\
 b &amp; c &amp; -c &amp;-b \\\
 a &amp; -a &amp; -a &amp; a \\\
 c &amp; -b &amp; b &amp; -c
\end{bmatrix}
[X]
\begin{bmatrix}
 a &amp; b &amp; a &amp; c  \\\
 a &amp; c &amp; -a &amp; -b \\\
 a &amp; -c &amp; -a &amp; b \\\
 a &amp; -b &amp; a &amp; -c
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code&gt;三个矩阵相乘，就是DCT转换的公式 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;$Y=C_f * X * C_f^t&lt;/script&gt;$&lt;/p&gt;

&lt;p&gt;       为了保证正交，a,b,c,d取值如下&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a=\frac{1}{2},b=\sqrt{\frac{1}{2}}cos \left( \frac{\pi}{8} \right),c=\sqrt{\frac{1}{2}}cos \left( frac{3\pi}{8} \right),d=\frac{c}{b}&lt;/script&gt;

&lt;p&gt;       DCT变换公式可改为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix}
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\begin{bmatrix}
 a &amp;   &amp;   &amp;  \\\
   &amp; b &amp;   &amp;  \\\
   &amp;   &amp; a &amp;  \\\
   &amp;   &amp;   &amp; b
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       把两边的对称矩阵移到左边可得：(对角阵移项)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 a^{-1} &amp;   &amp;   &amp;  \\\
   &amp; b^{-1} &amp;   &amp;  \\\
   &amp;   &amp; a^{-1} &amp;  \\\
   &amp;   &amp;   &amp; b^{-1}
\end{bmatrix}
[Y]
\begin{bmatrix}
 a^{-1} &amp;   &amp;   &amp;  \\\
   &amp; b^{-1} &amp;   &amp;  \\\
   &amp;   &amp; a^{-1} &amp;  \\\
   &amp;   &amp;   &amp; b^{-1}
\end{bmatrix}= \\\
Y\otimes
\begin{bmatrix}
 a^{-2} &amp; (ab)^{-1}  &amp; a^{-2}  &amp; (ab)^{-1} \\\
 (ab)^{-1}  &amp; b^{-2} &amp; (ab)^{-1}  &amp; b^{-2} \\\
 a^{-2} &amp; (ab)^{-1}  &amp; a^{-2}  &amp; (ab)^{-1} \\\
 (ab)^{-1}  &amp; b^{-2} &amp; (ab)^{-1}  &amp; b^{-2}
\end{bmatrix}=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       再移项变形可得：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; d &amp; -d &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 d &amp; -1 &amp;  1 &amp; -d
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; d\\\
 1 &amp; d &amp; -1 &amp; -1 \\\
 1 &amp; -d &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -d
\end{bmatrix}
\otimes
\begin{bmatrix}
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab &amp; b^2 \\\
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab  &amp; b^2
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       此时，d的值为0.4142。这样的话，还是实数运算。如我们令&lt;script type=&quot;math/tex&quot;&gt;$d=\frac{1}{2}&lt;/script&gt;$,则&lt;script type=&quot;math/tex&quot;&gt;$b=\sqrt{\frac{2}{5}}&lt;/script&gt;$,
&lt;script type=&quot;math/tex&quot;&gt;$c=\sqrt{\frac{1}{10}}&lt;/script&gt;$,同样，可以保证矩阵的正交，同时，可以把运算变为整数运算。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=\left( 
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 1 &amp; \frac{1}{2} &amp; -\frac{1}{2} &amp; -1 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 \frac{1}{2} &amp; -1 &amp; 1 &amp; -\frac{1}{2}
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; \frac{1}{2}\\\
 1 &amp; \frac{1}{2} &amp; -1 &amp; -1 \\\
 1 &amp; -\frac{1}{2} &amp; -1 &amp; 1 \\\
 1 &amp; -1 &amp; 1 &amp; -\frac{1}{2}
\end{bmatrix}
\right)
\otimes
\begin{bmatrix}
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab &amp; b^2 \\\
 a^2 &amp; ab  &amp; a^2  &amp; ab \\\
 ab  &amp; b^2 &amp; ab   &amp; b^2
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;把&lt;script type=&quot;math/tex&quot;&gt;$\frac{1}{2}&lt;/script&gt;$提到矩阵之外，并与右边的矩阵点乘合并，得:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=(C_fXC_f^T)\otimes E_f 
\\\=
\left(
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix}
\right)
\otimes
\begin{bmatrix}
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2} &amp; \frac{b^2}{4}\\\
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2}   &amp; \frac{b^2}{4}
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       其中，&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
C_f=
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix},
E_f=
\begin{bmatrix}
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2} &amp; \frac{b^2}{4}\\\
 a^2 &amp; \frac{ab}{2}  &amp; a^2  &amp; \frac{ab}{2} \\\
 \frac{ab}{2}  &amp; \frac{b^2}{4} &amp; \frac{ab}{2}   &amp; \frac{b^2}{4}
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       在H264编码的JM编码器中，变换只包括：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       后面的点乘实际上是在量化过程中进行，因为后面的点乘还有实数运算，实数运算将不可避免地产生精度误差,而且运算量巨大。而量化本身就会丢失一些信号，因些，这些实数运算放在量化过程中将大大的降低变换的运算率同时又不明显影响精度？[博主sno的解释: 之所有把后面的Ef和这里分割开，是因为在转换和量化这一步，不可避免的会遇到乘法操作，这里说的只用加减和移位操作，是在这三个矩阵乘法大数据量运算之间只使用加减和移位，可以把64次的乘法运算转为只有两次的乘法运算，极大的减少消耗，在量化的时候，再对每个W[i][j]分别进行乘法操作。]&lt;/p&gt;

&lt;p&gt;       然而，4X4的矩阵运算如果按常规算法的话仍要进行64次乘法运算和48次加法，这将耗费较多的时间，于是在H.264中，有一种改进的算法（蝶形算法）可以减少运算的次数。这种矩阵运算算法构造非常巧妙，利用构造的矩阵的整数性质和对称性，可完全将乘法运算转化为加法运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.163.com/photo/-IW9juRdL0FtEDdpN6KBXQ==/1183883752046274032.jpg&quot; alt=&quot;蝶形运算示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;变换过程在JM编码器中的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//  Horizontal transform水平变换，其实就是左乘Cf,
&lt;/code&gt;&lt;/pre&gt;

  	for (j=0; j &amp;lt; BLOCK_SIZE &amp;amp;&amp;amp; !lossless_qpprime; j++)

  	{

&lt;pre&gt;&lt;code&gt;        for (i=0; i &amp;lt; 2; i++)

{

  i1=3-i;

  m5[i]=img-&amp;gt;m7[i][j]+img-&amp;gt;m7[i1][j];

  m5[i1]=img-&amp;gt;m7[i][j]-img-&amp;gt;m7[i1][j];

}

img-&amp;gt;m7[0][j]=(m5[0]+m5[1]);

img-&amp;gt;m7[2][j]=(m5[0]-m5[1]);

img-&amp;gt;m7[1][j]=m5[3]*2+m5[2];

img-&amp;gt;m7[3][j]=m5[3]-m5[2]*2;
&lt;/code&gt;&lt;/pre&gt;

  	}

  	//  Vertical transform垂直变换，其实就是右乘CfT

  	for (i=0; i &amp;lt; BLOCK_SIZE &amp;amp;&amp;amp; !lossless_qpprime; i++)

  	{

&lt;pre&gt;&lt;code&gt;        for (j=0; j &amp;lt; 2; j++)

{

  j1=3-j;

  m5[j]=img-&amp;gt;m7[i][j]+img-&amp;gt;m7[i][j1];

  m5[j1]=img-&amp;gt;m7[i][j]-img-&amp;gt;m7[i][j1];

}

img-&amp;gt;m7[i][0]=(m5[0]+m5[1]);

img-&amp;gt;m7[i][2]=(m5[0]-m5[1]);

img-&amp;gt;m7[i][1]=m5[3]*2+m5[2];

img-&amp;gt;m7[i][3]=m5[3]-m5[2]*2;
&lt;/code&gt;&lt;/pre&gt;

  	}

&lt;h3 id=&quot;section-1&quot;&gt;分析该蝶形算法&lt;/h3&gt;

&lt;p&gt;       上面的JM代码就是计算下面三个4x4矩阵的过程。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
 1 &amp; 1 &amp; 1 &amp; 1\\\
 2 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 1 \\\
 1 &amp; -2 &amp; 2 &amp; -1
\end{bmatrix}
[X]
\begin{bmatrix}
 1 &amp; 2 &amp; 1 &amp; 1\\\
 1 &amp; 1 &amp; -1 &amp; -2 \\\
 1 &amp; -1 &amp; -1 &amp; 2 \\\
 1 &amp; -2 &amp; 1 &amp; -1
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;       分析一下前两个矩阵的乘法，只分析他们结果矩阵的第一行。有什么办法可以减少运算量呢？首先采用传统方法计算，得到结果：&lt;/p&gt;

&lt;p&gt;X[0] = x[00]+x[10]+x[20]+x[30]&lt;/p&gt;

&lt;p&gt;X[1] = 2 * x[00]+x[10]-x[20]-2 * x[30]&lt;/p&gt;

&lt;p&gt;X[2]= x[00]-x[10]-x[20]+x[30]&lt;/p&gt;

&lt;p&gt;X[3] = x[00]-2x[10]+2x[20]-x[30]&lt;/p&gt;

&lt;p&gt;       计算代价是16次乘法12次加法，考虑到矩阵的1的乘法可以省略，去除8个乘1，还需要8次乘法和12次加法。那么我们再仔细思考他们的相关性，从一般算法意义上来说，可以用空间代价换时间代价，比如设置中间变量来减少计算次数。用不同的颜色把需要重复运算的部分标上，作为中间变量。&lt;/p&gt;

&lt;p&gt;X[0] = &lt;font color=&quot;green&quot;&gt;x[00]&lt;/font&gt;+&lt;font color=&quot;blue&quot;&gt;x[10]&lt;/font&gt;+&lt;font color=&quot;blue&quot;&gt;x[20]&lt;/font&gt;+&lt;font color=&quot;green&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[1] = &lt;font color=&quot;purple&quot;&gt;2 * x[00]&lt;/font&gt;+x[10]-x[20]-2 * &lt;font color=&quot;purple&quot;&gt;2 * x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[2]= &lt;font color=&quot;green&quot;&gt;x[00]&lt;/font&gt;-&amp;lt;/font&amp;gt;+&lt;font color=&quot;blue&quot;&gt;x[10]&lt;/font&gt;-&lt;font color=&quot;blue&quot;&gt;x[20]&lt;/font&gt;+&lt;font color=&quot;green&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;X[3] = &lt;font color=&quot;purple&quot;&gt;x[00]&lt;/font&gt;-2x[10]+2x[20]-&lt;font color=&quot;purple&quot;&gt;x[30]&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;那么提取出来的中间变量将是：&lt;/p&gt;

&lt;font color=&quot;green&quot;&gt;x[00]+x[30]&lt;/font&gt;

&lt;font color=&quot;purple&quot;&gt;x[00]-x[30]&lt;/font&gt;

&lt;font color=&quot;blue&quot;&gt;x[10]+x[20]&lt;/font&gt;

&lt;p&gt;x[10]-x[20]&lt;/p&gt;

&lt;p&gt;       存储了这四个中间变量，我们对比看看蝶形图，和图中第一层的算式相符合。用这些中间变量来组合，就可以把最终的X[0]..X[3], 计算出来。这样，就把运算量降低到2个乘法和8个加法，剩余的运算就是叠代这个算法。&lt;/p&gt;

&lt;p&gt;       所以，可以得出以下结论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;这个蝶形图和一般意义的FFT或FDCT蝶形图不同，是对H.264在整数DCT基础上的具体算法优化，只对于以上Cf矩阵。&lt;/li&gt;
  &lt;li&gt;计算过程是把上面的三个4x4矩阵乘法分成两两矩阵相乘。再把残差矩阵和后来的中间结果Cf x X一行行分别输入蝶形图进行一维整数DCT计算。&lt;/li&gt;
  &lt;li&gt;蝶形图优化思想就是提取矩阵的相关部分，定义中间变量，减少运算次数。［sno博主添加：这里很重要，之所以使用蝶形算法，就是统计一下多次运行的规律，不重复计算相关的量。］&lt;/li&gt;
  &lt;li&gt;sno: 矩阵相乘 A*B   就是把A矩阵当前元素所在的这一行乘以B矩阵当前元素所在的这一列。代码实现如下&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;
	int  matrix_multiply(int a[4][4],int b[4][4],int c[4][4])
	{
		int
    	int i,j,k;
    	for(i=0;i&amp;lt;4;i++)
            for(j=0;j&amp;lt;4;j++)
            {
            	c[i][j]=0;
                for(k=0;k&amp;lt;4;k++)
                	c[i][j]+=a[i][k]*b[k][j];  ///c[i][j]=a的i这一行*b的j这一列的总和 ,这里是累计和                          
            }
        return 0;        
	} 
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Thu, 07 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/07/h264_dctmd.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/07/h264_dctmd.html</guid>
        
        <category>数字图像处理</category>
        
        <category>离散余弦变换</category>
        
        <category>蝶形运算</category>
        
        
        <category>数字图像处理</category>
        
      </item>
    
      <item>
        <title>数字图像处理-傅里叶变换,离散余弦变换</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;1.傅里叶变换&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.1. 一维离散傅里叶变换&lt;/h3&gt;
&lt;p&gt;       定义:设&lt;script type=&quot;math/tex&quot;&gt;${ f(n)|n=0,..,N-1}&lt;/script&gt;$为一维信号的N个采样值,其离散傅立叶变换及其逆变换分别为:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F(u)=\frac{1}{N}\sum_{k=0}^{N-1}f(k)e^{-j2\pi\frac{uk}{N}},u=0,1,\dots,N-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(k)=\sum_{u=0}^{N-1}F(u)e^{j2\pi\frac{uk}{N}},k=0,1,\dots,N-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
缩写 W= e^{\frac{-j2\pi}{N}}
\begin{matrix}
W^0 = 1 &amp; W^1=\frac{1-j}{\sqrt{2}} \\\
W^2 = -j &amp; W^3=\frac{-1-j}{\sqrt{2}} \\\
W^4 = -1 &amp; W^5=\frac{-1+j}{\sqrt{2}} \\\
W^6 = j &amp; W^7=\frac{1+j}{\sqrt{2}}
\end{matrix} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.2. 二维离散傅里叶变换&lt;/h3&gt;
&lt;p&gt;       定义:设&lt;script type=&quot;math/tex&quot;&gt;${f(x,y)|x=0,..,N-1, y=0,..,M-1}&lt;/script&gt;$为二维图像信号 其离散傅立叶变换及其逆变换分别为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F(u,v)=\frac{1}{\sqrt{MN}}\sum_{x=0}^{N-1}\sum\_{y=0}^{M-1}f(x,y)e^{-j2\pi(\frac{ux}{N}+\frac{vy}{M})},u=0,1,\dots,N-1,v=0,1,\dots,M-1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x,y)=\frac{1}{\sqrt{MN}}\sum_{u=0}^{N-1}\sum\_{v=0}^{M-1}F(u,v)e^{j2\pi(\frac{ux}{N}+\frac{vy}{M})},u=0,1,\dots,N-1,v=0,1,\dots,M-1&lt;/script&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2. 快速傅里叶变换&lt;/h3&gt;
&lt;p&gt;       设&lt;script type=&quot;math/tex&quot;&gt;$N=2^L&lt;/script&gt;$(&lt;script type=&quot;math/tex&quot;&gt;$L&lt;/script&gt;$为正整数)。下面按照&lt;script type=&quot;math/tex&quot;&gt;$n&lt;/script&gt;$为奇数和偶数将序列&lt;script type=&quot;math/tex&quot;&gt;${f(n)}&lt;/script&gt;$进行划分，记为
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{cases}
g(n) &amp;= f(2n) \\\
h(n) &amp;= f(2n+1)
\end{cases}
\left ( n=0,1,2,\dots,\frac{N}{2}-1 \right ) %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;则离散傅里叶变换可以改写成下面的形式&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
F(m) &amp;= \sum_{n=0}^{N-1}f(n)W_N^mn \\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}f(2n)W_N^{m(2n)} + \sum\_{n=0}^{\frac{N}{2}-1}f(2n+1)W_N^{m(2n+1)}\\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}f(2n)W\_{\frac{N}{2}}^{mn} + \sum\_{n=0}^{\frac{N}{2}-1}f(2n+1)W\_{\frac{N}{2}}^{mn}W\_N^m\\\
&amp;= \sum\_{n=0}^{\frac{N}{2}-1}g(n)W\_{\frac{N}{2}}^{mn} + W\_N^m\sum\_{n=0}^{\frac{N}{2}-1}h(n)W\_{\frac{N}{2}}^{mn}\\\
&amp;= G(m) + W\_N^mH(m)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;式中，&lt;script type=&quot;math/tex&quot;&gt;$G(m)&lt;/script&gt;$和&lt;script type=&quot;math/tex&quot;&gt;$H(m)&lt;/script&gt;$分别是&lt;script type=&quot;math/tex&quot;&gt;$g(n)&lt;/script&gt;$和&lt;script type=&quot;math/tex&quot;&gt;$h(n)&lt;/script&gt;$的离散傅里叶变换。一个长度为&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$的DFT可以转化为两个长度为&lt;script type=&quot;math/tex&quot;&gt;$\frac{N}{2}&lt;/script&gt;$的DFT。二维FFT可以由两次一维FFT得到。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3.关键算法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;private void setData1(Complex[] data, int power)
{
    this.power = power;

    //角度
    double angle;

    //计算FFT1变换的点数
    count = 1 &amp;lt;&amp;lt; power;

    //分配空间
    wc = new Complex[count / 2];
    x = new Complex[count];
    x1 = new Complex[count];
    x2 = new Complex[count];
    fd1 = new Complex[count];

    //初始化
    for (i = 0; i &amp;lt; count / 2; i++)
        wc[i] = new Complex();

    for (i = 0; i &amp;lt; count; i++)
    {
        x[i] = new Complex();
        x1[i] = new Complex();
        x2[i] = new Complex();
        fd1[i] = new Complex();
    }

    //计算加权系数
    for (i = 0; i &amp;lt; count / 2; i++)
    {
        angle = -i * Math.PI * 2 / count;
        wc[i].re = Math.cos(angle);
        wc[i].im = Math.sin(angle);
    }

    //将实域点写入x1
    for (i = 0; i &amp;lt; count; i++)
        x1[i] = data[i];
} 其中，$$$2^{power}=iw或ih$$$，与进行傅里叶变换是行或列有关，Complex表示复数。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;2.离散余弦变换&lt;/h2&gt;

&lt;h3 id=&quot;dft&quot;&gt;2.1.DFT存在的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DFT的参数都是复数,在数据的描述上相当于 实数的两倍。&lt;/li&gt;
  &lt;li&gt;为此,我们希望有一种能够达到相同功能但数 据量又不大的变换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dct-ii&quot;&gt;2.2.DCT-II公式&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_k = \sum_{n=0}^{N-1}x_ncos \left[ \frac{\pi}{N}\left( n+\frac{1}{2} \right) \right]&lt;/script&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.3.一维离散余弦变换&lt;/h3&gt;
&lt;p&gt;       一维&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$点离散余弦变换(DCT)可以表示为:
&lt;script type=&quot;math/tex&quot;&gt;y_k=C_k\sum_{n=0}^{N-1}x_ncos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;
其中，&lt;script type=&quot;math/tex&quot;&gt;$x_n&lt;/script&gt;$是输入时域序列中的第&lt;script type=&quot;math/tex&quot;&gt;$n&lt;/script&gt;$项，&lt;script type=&quot;math/tex&quot;&gt;$y_k&lt;/script&gt;$是输出频域序列中的第&lt;script type=&quot;math/tex&quot;&gt;$k&lt;/script&gt;$项，系数&lt;script type=&quot;math/tex&quot;&gt;$C_k&lt;/script&gt;$定义如下:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
C_k=
\begin{cases}
   \sqrt{\frac{1}{N}} &amp;\mbox{ $k=0$ }\\\
   \sqrt{\frac{2}{N}} &amp;\mbox{ $k=1,2,\dots,N-1$ }
   \end{cases} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;       一维&lt;script type=&quot;math/tex&quot;&gt;$N&lt;/script&gt;$点离散余弦逆变换(IDCT)可以表示为:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_n=\sum\_{k=0}^{N-1}C_ky_kcos\frac{(2n+1)k\pi}{2N}&lt;/script&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.4.二维离散余弦变换&lt;/h3&gt;
&lt;p&gt;       二维图像&lt;script type=&quot;math/tex&quot;&gt;$N\times N&lt;/script&gt;$图像块的DCT可以理解为对图像块的每一列进行一维DCT，然后对进行变换的块每列再做一维DCT。表达式如下所示：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Y_{mn}=C_mC_n\sum\_{i=0}^{N-1}\sum\_{j=0}^{N-1}X\_{ij}cos\frac{(2j+1)n\pi}{2N}cos\frac{(2i+1)m\pi}{2N}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_{ij}=\sum\_{i=0}^{N-1}\sum\_{j=0}^{N-1}C_mC_nY\_{mn}cos\frac{(2j+1)n\pi}{2N}cos\frac{(2i+1)m\pi}{2N}&lt;/script&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.5.关键算法&lt;/h3&gt;
&lt;p&gt;       求变换矩阵&lt;script type=&quot;math/tex&quot;&gt;$A&lt;/script&gt;$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void coeff(double[][] dct_coef, int n)
	{
    double sqrt_1 = 1.0 / Math.sqrt(2.0);

    for (int i = 0; i &amp;lt; n; i++)
        dct_coef[0][i] = sqrt_1;

    //初始化DCT系数
    for (int i = 1; i &amp;lt; n; i++)
        for (int j = 0; j &amp;lt; n; j++)
            dct_coef[i][j] = Math.cos(i * Math.PI * (j + 0.5) /((double)n));
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;       DCT正变换&lt;script type=&quot;math/tex&quot;&gt;$Y=AXA^T&lt;/script&gt;$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void dct(double[][] a, double[][] b, double[][] c, int n)
{
    double x;
    double[][] af = new double[n][n];
	for (int i = 0; i &amp;lt; n; i++)
    {
        for (int j = 0; j &amp;lt; n; j++)
        {
            x = 0.0;
            for (int k = 0; k &amp;lt; n; k++)
                x += a[i][k] * b[k][j];
            af[i][j] = x;
        }
    }
    for (int i = 0; i &amp;lt; n; i++)
    {
        for (int j = 0; j &amp;lt; n; j++)
        {
            x = 0.0;
            for (int k = 0; k &amp;lt; n; k++)
                x += c[i][k] * af[k][j];
            a[i][j] = 2.0 * x / ((double)n);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;script type=&quot;math/tex&quot;&gt;$a,b,c&lt;/script&gt;$矩阵分别为被变换的矩阵&lt;script type=&quot;math/tex&quot;&gt;$X&lt;/script&gt;$,变换矩阵的转置&lt;script type=&quot;math/tex&quot;&gt;$A^T&lt;/script&gt;$,变换矩阵&lt;script type=&quot;math/tex&quot;&gt;$A&lt;/script&gt;$&lt;/p&gt;
</description>
        <pubDate>Tue, 05 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post02.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post02.html</guid>
        
        <category>数字图像处理</category>
        
        <category>傅里叶变换</category>
        
        <category>离散余弦变换</category>
        
        
        <category>数字图像处理</category>
        
      </item>
    
      <item>
        <title>数字图像处理-直方图计算和灰度线性变换</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;1.图像的读取和显示&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.1图像的读取&lt;/h3&gt;
&lt;p&gt;        重点是使用awt的Image类,java本身支持jepg,gif和png三种图像格式。&lt;br /&gt;
        关键代码如下:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;public Image openImage(String is, MediaTracker tracker )
{
	Image im = null;
	//用MediaTracker跟踪图像加载
	im = Toolkit.getDefaultToolkit().getImage(is);
	tracker.addImage(im,0);

	//等待图像完成加载
	try	{ tracker.waitForID(0);	}
	catch(InterruptedException e){ e.printStackTrace();}
	return im;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.2图像的显示&lt;/h3&gt;
&lt;p&gt;        代码实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//显示两幅图与第2幅图像标题
//im   -- 输入图
//istr -- 输入图标题
//om   -- 输出图
//ostr -- 输出图标题
 
public void draw(Graphics g, Image im, String istr, Image om, String ostr)
{
    g.clearRect(0, 0, 530, 350);
    g.drawImage(im, 5,   50, null);
    g.drawImage(om, 270, 50, null);
    g.drawString(istr, 120, 320);
    g.drawString(ostr, 380, 320);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2.直方图的计算&lt;/h2&gt;
&lt;p&gt;        直方图的计算分别用&lt;script type=&quot;math/tex&quot;&gt;$w&lt;/script&gt;$和&lt;script type=&quot;math/tex&quot;&gt;$h&lt;/script&gt;$表示图像的宽度和高度。设灰度值&lt;script type=&quot;math/tex&quot;&gt;$ r_i&lt;/script&gt;$出现的频率为&lt;script type=&quot;math/tex&quot;&gt;$ n_i&lt;/script&gt;$，则&lt;strong&gt;直方图&lt;script type=&quot;math/tex&quot;&gt;$ H&lt;/script&gt;$&lt;/strong&gt;可用下式计算：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H(r_i)=\frac{n_i}{w\times h}&lt;/script&gt;

&lt;p&gt;        代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int[] getHist(int[] pix, int iw, int ih)
{
	int[] hist = new int[256];
    for(int i = 0; i &amp;lt; iw*ih; i++)
    {
        int grey = pix[i]&amp;amp;0xff;
        hist[grey]++;
    }
    return hist;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;3.灰度的线性变换&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;3.1彩色图像转变为灰度图像&lt;/h3&gt;
&lt;p&gt;        彩色图像转换为灰度图像的函数表达式如下：
&lt;script type=&quot;math/tex&quot;&gt;I=F(i,j)=\left \lfloor \frac{1}{3}(f_R(i,j)+f_G(i,j)+f_B(i,j)) \right \rfloor (i=0,1,···,M-1;j=0,1,···,N-1)&lt;/script&gt;
式中，记号&lt;script type=&quot;math/tex&quot;&gt;$\left \lfloor x \right \rfloor&lt;/script&gt;$表示不超过x的最大整数。利用上式求出&lt;script type=&quot;math/tex&quot;&gt;$I&lt;/script&gt;$值后，给输出图像的R、G、B分量都赋值&lt;script type=&quot;math/tex&quot;&gt;$I&lt;/script&gt;$，就能转变成灰度图像。&lt;br /&gt;
        代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//转变为灰度图像
public int[] toGray(int[] pix, int iw, int ih)
{
    ColorModel cm = ColorModel.getRGBdefault();
    int r, g, b, gray;

    for(int i = 0; i &amp;lt; iw*ih; i++)
    {
        r = cm.getRed(pix[i]);
        g = cm.getGreen(pix[i]);
        b = cm.getBlue(pix[i]);
        gray =(int)((r + g + b) / 3);
        pix[i] = 255 &amp;lt;&amp;lt; 24|gray &amp;lt;&amp;lt; 16|gray &amp;lt;&amp;lt; 8|gray;
    }
    return pix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;3.2图像的灰度线性变换&lt;/h3&gt;
&lt;p&gt;        记&lt;script type=&quot;math/tex&quot;&gt;$p&lt;/script&gt;$为变换的斜率，&lt;script type=&quot;math/tex&quot;&gt;$q&lt;/script&gt;$为截距，则灰度线性变换的数学公式如下：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
F(i,j)=
   \begin{cases}
   0 &amp;\mbox{ $f&#39;(i,j)&lt;0$ }\\\
   f&#39;(i,j) &amp;\mbox{ $0 \leq f&#39;(i,j) \leq 255$ }\\\
   255 &amp;\mbox{$f&#39;(i,j)&gt;255$ }
   \end{cases} %]]&gt;&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;f&#39;(i,j)=\left \lfloor p·f(i,j)+q \right \rfloor (i=0,1,···,M-1;j=0,1,···,N-1)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;        代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//线性变换
public int[] linetrans(int[] pix, int iw, int ih,float p, int q)
{
	ColorModel cm = ColorModel.getRGBdefault();
    int r, g, b;
	
	for(int i = 0; i &amp;lt; iw*ih; i++)
    {
        r = cm.getRed(pix[i]);
        g = cm.getGreen(pix[i]);
        b = cm.getBlue(pix[i]);

        //增加图像亮度
        r  = (int)(p * r + q);
        g  = (int)(p * g + q);
        b  = (int)(p * b + q);

        if(r &amp;gt;= 255)   r = 255;
        if(g &amp;gt;= 255)   g = 255;
        if(b &amp;gt;= 255)   b = 255;

        pix[i] = 255 &amp;lt;&amp;lt; 24|r &amp;lt;&amp;lt; 16|g &amp;lt;&amp;lt; 8|b;
    }
    return pix;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 05 May 2015 00:00:00 +0800</pubDate>
        <link>http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post01.html</link>
        <guid isPermaLink="true">http://thisisagoodname.github.io//%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2015/05/05/post01.html</guid>
        
        <category>数字图像处理</category>
        
        <category>图像直方图计算</category>
        
        <category>图像灰度拉伸</category>
        
        
        <category>数字图像处理</category>
        
      </item>
    
  </channel>
</rss>
